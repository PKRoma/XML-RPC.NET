<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
<head>
<title>XML-RPC.NET FAQ</title>
<meta name="keywords" content="Charles Cook, XML-RPC, xmlrpc, .Net, C#, Cook Computing" />
<link href="../css/styles.css" rel="stylesheet" type="text/css"/>
<!--[if IE]>
<link href="../css/styles_ie.css" rel="stylesheet" type="text/css">			
<![endif]-->
</head>

<body>

<div id="googlead">
<script type="text/javascript"><!--
    google_ad_client = "pub-1318882515896843";
    /* XML-RPC.NET */
    google_ad_slot = "2262415944";
    google_ad_width = 120;
    google_ad_height = 600;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

<div id="googlink" >
<script type="text/javascript"><!--
    google_ad_client = "pub-1318882515896843";
    /* XML-RPC.NET Links */
    google_ad_slot = "0494440579";
    google_ad_width = 120;
    google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>

</div>

<div id="content">
<div id="headermenu" >
    <a href="../index.html">Home</a>
    &nbsp;
    <a href="http://www.cookcomputing.com">Cook Computing</a>
</div>

<h1>XML-RPC.NET FAQ</h1>

<p>Version 3.0.0 (work in progress) 12th March 2012. &copy; Charles Cook, 2002-2011.</p>
<p>Please send feedback, corrections, etc, to xmlrpcfaq@gmail.com.</p>
<h2>Contents</h2>
<p>1. Introduction</p>
  
<div class="toc">
<p class="indent">
1.1 <a href="#1.1">What is XML-RPC?</a><br/>
1.2 <a href="#1.2">What is XML-RPC.NET?</a><br/>
1.3 <a href="#1.3">Why use XML-RPC instead of SOAP?</a><br/>
1.4 <a href="#1.4">Where do I obtain XML-RPC.NET from?</a><br/>
1.5 <a href="#1.5">How do I install XML-RPC.NET?</a><br/>
1.6 <a href="#1.6">Can I install XML-RPC.NET in the GAC?</a><br/>
1.7 <a href="#1.7">How do I build with XML-RPC.NET?</a><br/>
1.8 <a href="#1.8">How does XML-RPC.NET represent XML-RPC requests and responses?</a><br/>
1.9 <a href="#1.9">How are XML-RPC simple types mapped onto .NET data types?</a><br/>
1.10 <a href="#1.10">How are XML-RPC structs represented as .NET types?</a><br/>
1.11 <a href="#1.11">What if the XML-RPC struct member name is not valid in .NET?</a><br/>
1.12 <a href="#1.12">How are XML-RPC arrays represented as .NET types?</a><br/>
1.13 <a href="#1.13">Is XML-RPC.NET CLS Compliant?</a><br/>
1.14 <a href="#1.14">Why are my struct members ignored?</a><br/>
1.15 <a href="#1.15">Can I specify struct members as optional?</a><br/>
1.16 <a href="#1.16">How do I specify data whose type is not known until runtime?</a> <br/>
1.17 <a href="#1.17">With which versions of .NET is XML-RPC.NET compatible?</a> <br/>
1.18 <a href="#1.18">Does XML-RPC.NET support the &lt;nil&gt; extension?</a> <br/>
1.19 <a href="#1.19">Can .NET enum types be mapped to/from XML-RPC &lt;i4&gt; and &lt;i8&gt; values?</a>

</p>

<p>2. Clients</p>
  
<p class="indent">
2.1 <a href="#2.1">How do I implement an XML-RPC client?</a><br/>
2.2 <a href="#2.2">What 
if the XML-RPC method name is not valid in my programming language?<br/>
</a>
2.3 <a href="#2.3">Can I specify the server endpoint URL at runtime?</a><br/>
2.4 <a href="#2.4">How do I set a timeout on a proxy method call?</a><br/>
2.5 <a href="#2.5">How do I supply authentication credentials?</a><br/>
2.6 <a href="#2.6">Can I specify custom HTTP headers?</a> <br/>
2.7 <a href="#2.7">How do I send cookies with a request?</a> <br/>
2.8 <a href="#2.8">How do I make an asynchronous XML-RPC request?</a><br/>
2.9 <a href="#2.9">How do I poll for the result of an asynchronous call?</a><br/>
2.10 <a href="#2.10">How do I receive a callback on completion of an asynchronous call?</a><br/>
2.11 <a href="#2.11">What is the asyncState parameter used for?</a><br/>
2.12 <a href="#2.12">How do I implement a client in VB.NET?</a><br/>
2.13 <a href="#2.13">Why does the following code cause an exception?</a><br/>
2.14 <a href="#2.14">How do I implement a client in Managed C++?</a><br/>
2.15 <a href="#2.15">How do I implement a client in JScript.NET?</a><br/>
2.16 <a href="#2.16">Do proxies support the Introspection API?</a><br/>
2.17 <a href="#2.17">Can I define a proxy method to return void?</a><br/>
2.18 <a href="#2.18">How do I specify a proxy server when making an XML-RPC request?</a> <br/>
2.19 <a href="#2.19">Is a client proxy thread-safe?</a><br />
2.20 <a href="#2.20">How do I call an XML-RPC method with a variable number of parameters?</a><br />
2.21 <a href="#2.21">Can I configure the use of &lt;int&gt; instead of &lt;i4&gt;?</a><br />
2.22 <a href="#2.22">Does XML-RPC.NET accept non-standard XML-RPC responses?</a> <br />
2.23 <a href="#2.23">Can I configure method names at runtime?</a> <br />
2.24 <a href="#2.24">What is the Expect100Continue property used for?</a> <br /> 
2.25 <a href="#2.25">What is the KeepAlive property used for?</a> <br />
2.26 <a href="#2.26">Why does XML-RPC.NET throw XmlRpcIllFormedXmlException?</a> <br />
2.27 <a href="#2.27">How can I stop a WebException being thrown?</a> <br />
2.28 <a href="#2.28">Can a proxy interface contain overloaded methods?</a>  <br />
2.29 <a href="#2.29">How do I implement a client in Boo?</a> <br />
2.30 <a href="#2.30">Can I configure the client to not use the &lt;string&gt; tag?</a><br />
2.31 <a href="#2.31">How do I configure client support for Accept-Encoding?</a><br />
2.32 <a href="#2.32">How do I prevent an empty params element in a request?</a><br />
2.33 <a href="#2.33">Can I retrieve the HTML response headers and cookies?</a><br />
2.34 <a href="#2.34">How do I call an XML-RPC method which requires named parameters in a struct?</a><br />
2.35 <a href="#2.35">Can I use the NonSerialized attribute on struct members?</a><br />

</p>

  
<p>3. Servers</p>
  
<p class="indent">
3.1 <a href="#3.1">What are the different ways in which an XML-RPC server can be implemented?</a><br/>
3.2 <a href="#3.2">How do I implement an XML-RPC server in IIS?</a><br/>
3.3 <a href="#3.3">How do I implement an XML-RPC server using .NET Remoting?</a><br/>
3.4 <a href="#3.4">How do I implement an XML-RPC server in IIS using .NET Remoting?</a><br/>
3.5 <a href="#3.5">Do XML-RPC.NET servers implement the XML-RPC Introspection API?</a><br/>
3.6 <a href="#3.6">What is Automatic Documentation?</a><br/>
3.7 <a href="#3.7">How do I support authentication in my XML-RPC service?</a><a href="#How_do_I_support_authentication_in_my_XML-RPC_service"><br/>
  </a> 
3.8 <a href="#3.8">Can I implement a server which supports both XML-RPC and SOAP?</a><br/>
3.9 <a href="#3.9">Can I run XML RPC.NET services with other web servers</a>?<br/>
3.10 <a href="#3.10">Can I implement services in other languages?</a>?<br/>
3.11 <a href="#3.11">Can I implement a service in an ASHX file?</a>?<br/>
3.12 <a href="#3.12">How do I implement an XML-RPC server using HttpListener?</a>?<br/>
3.13 <a href="#3.13">Can I customise the XML returned by a service?</a>?
</p>

<p>4. Error Handling</p>
  
<p class="indent">4.1 <a href="#4.1">How are 
XML-RPC Fault Responses represented?</a><br/>
4.2 <a href="#4.2">How are other types of error returned?</a><br/>
4.3 <a href="#4.3">What happens if the return value of a proxy method is incorrect?</a> </p>
  
<p>5. Debugging</p>

<p class="indent">
5.1 <a href="#5.1">How do I monitor XML-RPC calls across the network?</a><br/>
5.2 <a href="#5.2">How do I debug an XML-RPC.NET service</a>?
</p>

<p>6. Miscellaneous</p>

<p class="indent">
6.1 <a href="#6.1">Which XML Encodings are Supported?</a><br/>
6.2 <a href="#6.2">Which Code Access Security Permissions are Required?</a><br/>
6.3 <a href="#6.3">Why is the key file not included in the distribution?</a><br/>
6.4 <a href="#6.4">How do I verify an XML-RPC.NET assembly is genuine?</a><br/>
6.5 <a href="#6.5">Can I define an interface from which both the proxy and server classes are derived?</a><br/>
6.6 <a href="#6.6">How do I implement a client where reflection is not allowed?</a><br/>
6.7 <a href="#6.7">Why does my client throw exception "Invoke on non-existent proxy method"?</a><br/>
6.8 <a href="#6.8">Does XmlRpcClientProtocol.Invoke use params for the array of parameters?</a> <br/>
6.9 <a href="#6.9">How do I manually implement asynchronous requests?</a> <br/>
6.10 <a href="#6.10">Does XML-RPC.NET work with Mono?</a><br /> 
6.11 <a href="#6.11">Does XML-RPC.NET work with .Net Compact Framework?</a> <br />
6.12 <a href="#6.12">How does the XML-RPC.NET license affect my product?</a> <br /> 
6.13 <a href="#6.13">How do I build XML-RPC.NET?</a> 
</p>
 
  
<p>7. Resources</p>
  
<p class="indent">
7.1 <a href="#7.1">XML-RPC Specification</a><br/>
7.2 <a href="#7.2">Books</a><br/>
7.3 <a href="#7.3">Websites</a><br/>
7.4 <a href="#7.4">Mailing Lists</a><br/>
7.5 <a href="#7.5">Articles and Tutorials</a><br/>
7.6 <a href="#7.6">Sample Services</a>
</p>

</div> <!-- toc -->

<h2>1. Introduction</h2>

<h3><a id="1.1"></a>1.1 What is XML-RPC?</h3>

<p>
To quote the XML-RPC.com site:
</p>

<p>
"It's a spec and a set of implementations that allow software running 
on disparate operating systems, running in different environments to make procedure 
calls over the Internet. It's remote procedure calling using HTTP as the transport 
and XML as the encoding. XML-RPC is designed to be as simple as possible, while 
allowing complex data structures to be transmitted, processed and returned.";
</p>


<h3><a id="1.2"></a>1.2 What is XML-RPC.NET?</h3>
<p>
XML-RPC.NET is a .NET class library for implementing XML-RPC clients and servers. 
</p>


<h3><a id="1.3"></a>1.3 Why use XML-RPC instead of SOAP?</h3>

<p>
If your clients and servers are all running in the .NET environment there is 
no point in using XML-RPC: .NET provides excellent support for SOAP and XML-RPC 
doesn't have any features not provided by SOAP (other than simplicity).
</p>

<p>
If you use .NET clients and want to connect to XML-RPC servers running under 
any OS then XML-RPC.NET is a good choice.
</p>

<p>
If you want to implement a server in the .NET environment which is to be connected 
to by clients running in other environments, say Unix or Java, then XML-RPC 
may be an appropriate choice. SOAP is supported in many different environments 
but is considerably more complicated than XML-RPC and presents more opportunity  
for interop problems.
</p>


<h3><a id="1.4"></a>1.4 Where do I obtain XML-RPC.NET from?</h3>

<p>
XML-RPC.NET can be obtained from the XML-RPC.NET <a href="http://www.xml-rpc.net/">home 
page</a>.
</p>

<p>
Updates are announced at <a href="http://www.cookcomputing.com/">Cook Computing</a> 
and the Yahoo <a href="http://groups.yahoo.com/XMLRPCNET/">XMLRPCNET</a> group.
</p>


<h3><a id="1.5"></a>1.5 How do I install XML-RPC.NET?</h3>

<p>
Extract the files from the distribution zip file and reference the following assemblies 
depending on your application:

<ul>
<li>
<b>CookComputing.XmlRpcV2.dll</b> — .NET clients (.NET 2.0 upwards, compatible with .NET client profile)
</li>
<li>
<b>CookComputing.XmlRpcV2Server.dll</b> — .NET servers ((.NET 2.0 upwards, requires CookComputing.XmlRpc.dll)
</li>
<li>
<b>CookComputing.XmlRpcSilverlight.dll</b> — Silverlight clients (Silverlight 3 upwards)
</li>
<li>
<b>CookComputing.XmlRpcPhone.dll</b> — Windows Phone clients
</li>
</ul>

</p>

<p>
In the case of an XML-RPC web service running in IIS, the assembly is placed 
in the bin sub-directory of the virtual directory which is being used for the 
web service.
</p>

<h3><a id="1.6"></a>1.6 Can I install XML-RPC.NET in the GAC?</h3>

<p>
XML-RPC.NET is built with a strong name and so can be added to the Global Assembly 
Cache (GAC). To do this use the gacutil utility: 
</p>

<pre>gacutil /i CookComputing.XmlRpcV2.dll</pre>

<p>
If you're implementing a server application add the server assembly too:
</p>

<pre>gacutil /i CookComputing.XmlRpcV2Server.dll</pre>

<p>
Alternatively the dll(s) can be dragged and dropped into the winnt\assembly directory 
using Windows Explorer.
</p>


<h3><a id="1.7"></a>1.7 How do I build with XML-RPC.NET?</h3>

<p>
When compiling code which uses any of the classes in the XML-RPC.NET assembly, 
a reference to the assembly must be specified. 
</p>

<p>In Visual Studio .NET this is is achieved by using the References dialog which 
is invoked from the References item in the Solution Explorer. If compiling from 
the command line, the XmlRpc assembly is referenced like this:
</p>

<pre>csc /r:CookComputing.XmlRpcV2.dll myprogram.cs</pre>

<p>
If you are implementing an XML-RPC server, you must also reference the server assembly:
</p>

<pre>csc /r:CookComputing.XmlRpcV2.dll;CookComputing.XmlRpcV2Server.dll myprogram.cs</pre>


<h3><a id="1.8"></a>1.8 How does XML-RPC.NET represent XML-RPC requests and responses?</h3>
<p>
XML-RPC.NET clients represents an XML-RPC endpoint as a .NET interface whose methods 
map onto the corresponding XML-RPC methods. For example:
</p>

<pre>using CookComputing.XmlRpc;

public struct SumAndDiffValue 
{
  public int sum; 
  public int difference; 
}

[XmlRpcUrl("http://www.cookcomputing.com/sumAndDiff.rem")] 
public interface ISumAndDiff : IXmlRpcProxy
{ 
  [XmlRpcMethod] 
  SumAndDiffValue SumAndDifference(int x, int y);
} 
</pre>

<p>
A client automatically generates a proxy class which derives from the interface.
</p>

<p>
A server implements corresponding methods and exposes them as XML-RPC methods. 
</p>

<h3><a id="1.9"></a>1.9 How are XML-RPC simple types mapped onto .NET data types?</h3>

<p>
XML-RPC simple types are mapped to and from the following .NET types: 
</p>

<table width="90%" border="1" cellpadding="5" cellspacing="0" >
  <tr> 
    <td>&lt;i4&gt; or &lt;int&gt;</td>
    <td >System.Int32</td>
    <td>XML-RPC.NET by default outputs &lt;i4&gt;</td>
  </tr>
  <tr> 
    <td>&lt;i8&gt;</td>
    <td >System.Int64</td>
    <td>Extension to XML-RPC.</td>
  </tr>
  <tr> 
    <td >&lt;boolean&gt;</td>
    <td >System.Boolean</td>
    <td>&nbsp;</td>
  </tr>
  <tr> 
    <td >&lt;string&gt;</td>
    <td >System.String</td>
    <td>XML-RPC.NET always outputs the &lt;string&gt; element instead of just 
      a &lt;value&gt; element with text content</td>
  </tr>
  <tr> 
    <td >&lt;double&gt;</td>
    <td >System.Double</td>
    <td>&nbsp;</td>
  </tr>
  <tr> 
    <td >&lt;dateTime.iso8601&gt;</td>
    <td >System.DateTime</td>
    <td>&nbsp;</td>
  </tr>
  <tr> 
    <td >&lt;base64&gt;</td>
    <td >System.Byte[]</td>
    <td>&nbsp;</td>
  </tr>
  <tr> 
    <td >&lt;nil&gt;</td>
    <td >&nbsp;</td>
    <td>Extension to XML-RPC. See <a href="#1.18">section 1.18</a></td>
  </tr>
</table>


<h3><a id="1.10"></a>1.10 How are XML-RPC structs represented as .NET types?</h3>

<p>
An XML-RPC struct is a dictionary of name+member pairs and so is more 
flexible than a struct in C++ or C#. Depending on the particular XML-RPC method, 
the members of a struct are not necessarily fixed: a struct might contain a 
fixed set of members, a subset of a known set of members, or even an arbitrary 
set of members created at runtime. 
</p>

<p>
For cases where the members of the struct are fixed, the XML-RPC struct can 
be mapped onto a .NET struct or class, for example:
</p>

<pre>&lt;struct&gt;
  &lt;member&gt;
    &lt;name&gt;code&lt;/name&gt;
    &lt;value&gt;&lt;int&gt;2&lt;/int&gt;&lt;/value&gt;
  &lt;/member&gt;
  &lt;member&gt;
    &lt;name&gt;description&lt;/name&gt;
    &lt;value&gt;&lt;string&gt;File missing.&lt;/string&gt;&lt;/value&gt;
  &lt;/member&gt;
&lt;/struct&gt;</pre>

<p>
could map onto this C# struct:<br/>
</p>

<pre>struct errStruct<br/>{
  public int code;
  public string description;
}</pre>

<p>
or this C# class:
</p>

<pre>class errClass<br/>{
  public int code;
  public string description;
}</pre>

<p>
When mapping from an XML-RPC struct to a .NET struct or class, XML-RPC.NET ignores any 
members which are only in the XML-RPC struct, but throws an exception if a member 
is defined in the .NET type but is not in the XML-RPC struct (although it is possible
to specify that members are optional, see question <a href="#1.15">1.15</a>)
</p>

<p>
When mapping from a .NET struct or class to an XML-RPC struct, XML-RPC.NET simply maps 
every member of the .NET type to the XML-RPC struct (except where the NonSerializable 
attribute is used, see question <a href="#2.35">2.35</a>).
</p>

<p>In cases where the usage of the struct in the XML-RPC call is too flexible 
to be represented by a fixed data type, the XmlRpcStruct type can be used. This 
is a derivation of the .NET hashtable type and consists of name/member pairs 
representing the members of the XML-RPC struct. For example:
</p>

<pre>XmlRpcStruct bounds = new XmlRpcStruct();
bounds.Add(&quot;lowerBound&quot;, 18);
bounds.Add(&quot;upperBound&quot;, 139);<br/>...<br/>lowerBound = (int)bounds[&quot;lowerBound&quot;];<br/>upperBound = (int)bounds[&quot;upperBound&quot;];</pre>


<h3><a id="1.11"></a>1.11 What if the XML-RPC struct member name is not valid in .NET?</h3>

<p>
In some cases the name of a member in an XML-RPC struct might be invalid in 
the .NET programming language being used. To handle this the XmlRpcMember attribute 
is available. This allows an XML-RPC member name to be mapped to and from a 
different .NET name. For example:
</p>

<pre>public struct SumAndDiffValue
{ 
  [XmlRpcMember("sample.sum")] 
  public int sum; 
  [XmlRpcMember("sample.difference")] 
  public int difference; 
}</pre>


<h3><a id="1.12"></a>1.12 How are XML-RPC arrays represented as .NET types?</h3>

<p>
Where possible XML-RPC.NET maps XML-RPC arrays onto arrays of .NET types. Where 
this is not possible, for example where the members of the XML-RPC array are 
not of the same type, the mapping is to an instance of System.Object[].
</p>

<h3><a id="1.13"></a>1.13 Is XML-RPC.NET CLS Compliant?</h3>

<p>
XML-RPC.NET is fully Common Language Specification (CLS) compliant. This means 
that it can be used from any .NET language which is also CLS compliant, for 
example C#, VB.NET, or Managed Extensions for C++.
</p>


<h3><a id="1.14"></a>1.14 Why are my struct members ignored?</h3>

<p>
A common mistake with structs is to define them like this in C#:
</p>

<pre>public struct SumAndDiffValue
{ 
  int sum;
  int difference; 
}</pre>

<p>
or like this in VB.NET:
</p>

<pre>Public Structure SumAndDiffValue
  sum As Integer 
  difference As Integer 
End Structure</pre>

<p>
The mistake is that the members are not defined as public. This means the XML-RPC.NET 
library cannot recognize them without requiring extra security permissions associated 
with reflection. This might not be available in all circumstances, for example 
where the XML-RPC.NET assembly is downloaded by a client running in the Internet 
security zone, and so struct members are required to have public visibility. 
To take the C# case, the correct version of the struct would be: 
</p>

<pre>public struct SumAndDiffValue
{ 
  public int sum;
  public int difference; 
}</pre>


<h3><a id="1.15"></a>1.15 Can I specify struct members as optional?</h3>

<p>
By default when XML-RPC.NET deserializes XML-RPC structs to .NET structs or classes it 
assumes that former will contain members for all the public members defined in 
the latter (deserialization occurs when the server processes a request and when
the client processes a response).

However, some APIs use structs which have optional members. For example a struct
might always contain an "title" and "link" member but the "description" member 
might be optional. If the following struct is used as the return value of a 
method:
</p>

<pre>public struct SampleStruct
{
  public string title;
  public string link;
  public string description;
} 
</pre>

<p>
And the response from the server does not contain a "description" member, 
an exception will be thrown when the client attempts to deserialize the struct.
The solution is to attribute the member in the C# struct so that XML-RPC.NET 
knows that it is ok for the member to be missing:
</p>

<pre>public struct SampleStruct
{
  public string title;
  public string link;
  [XmlRpcMissingMapping(MappingAction.Ignore)]
  public string description;
} 
</pre>

<p>
If there are many optional members in a struct, it is easier to apply 
MappingAction.Ignore to the whole struct and then mark the members which 
are not optional. For example:
</p>

<pre>[XmlRpcMissingMapping(MappingAction.Ignore)]
public struct SampleStruct
{
  [XmlRpcMissingMapping(MappingAction.Error)]
  public string title;
  [XmlRpcMissingMapping(MappingAction.Error)]
  public string link;
  public string description;
} 
</pre>

<p>
If an XML-RPC struct member is optional and it is a reference type such as 
string, the .NET struct member will be set to null if the member is missing 
from the XML-RPC struct. Conversely if an optional .NET struct member is null, 
the corresponding member will not be output in the XML-RPC struct. 
In the case of a value type such as integer or bool, the .NET struct member 
will be set to the default value of the value type, e.g. zero for integer, if the
member is missing from the XML-RPC struct. However when serializing a value type 
the XML-RPC struct member will always be set because there is no equivalent 
of the null value. The solution in this case is to use nullable value types. 
</p>


<h4>
<a id="NullableTypes">Nullable Types</a> 
</h4>

<p>
For the .NET 2.0 version of XML-RPC.NET onwards it is possible to use the 
nullable int?, bool?, double?, and DateTime? types, as well as nullable struct
types, to represent optional struct members. When these are used, if an 
XML-RPC struct member is missing its corresponding .NET struct member will 
be set to null instead of the default value for the type if a non-nullable 
type had been used, for example null instead of zero for an integer. And 
going the other way, if the nullable .NET struct member is null, the 
resulting member will be omitted from the XML-RPC struct.
</p>

<pre>
public struct FooStruct
{
  public int x;
}

[XmlRpcMissingMapping(MappingAction.Ignore)]
public struct SampleStruct
{
  public int? optionalIntMember;
  public bool? optionalBoolMember;
  public double? optionalDoubleMember;
  public DateTime? optionalDateTimeMember;
  public FooStruct? optionalStructMember;
} 
</pre>


<h3><a id="1.16"></a>1.16 How do I specify data whose type is not known until runtime?</h3>

<p>
Sometimes the type of a parameter, return value, or struct member
is not known until runtime. In this scenario the System.Object datatype should
be used. For return values the actual type can be determined at runtime and 
handled appropriately.  
</p>


<h3><a id="1.17"></a>1.17 With which versions of .NET is XML-RPC.NET compatible??</h3>

<p>
The assemblies CookComputing.XmlRpc and CookComputing.XmlRpcServer are 
built for .NET 2.0 and so are compatible with this and later versions of .NET.
</p>

<p>
The assembly CookComputing.XmlRpcSilverlight is compatible with Silverlight 3 and later versions.
</p>

<p>
The assembly CookComputing.XmlRpcPhone is compatible with Windows Phone 7.
</p>


<h3><a id="1.18"></a>1.18 Does XML-RPC.NET support the &lt;nil&gt; extension?</h3>

<p>
XML-RPC.NET supports the <a href="http://ontosys.com/xml-rpc/extensions.php>">&lt;nil&gt; 
extension</a> by default without any additional configuration. 
</p>

<h4>Parameters</h4>

<p>
If a parameter is defined as a reference type or a nullable value type, and the value passed 
into the method is null, &lt;nil&gt; is used as the XML-RPC param value. For example, if this
method:
</p>

<pre>public interface INilMethods : IXmlRpcProxy
{ 
  [XmlRpcMethod] 
  void MethodTakingIntAndString(int? x, string str);
} 
</pre>

<p>
Is called like this:
</p>

<pre>
    proxy.MethodTakingIntAndString(null, null);
</pre>

<p>
The XML-RPC request will look like this:
</p>

<pre>&lt;xml version="1.0"?&gt;
&lt;methodCall&gt;
  &lt;methodName&gt;MethodTakingIntAndString&lt;/methodName&gt;
  &lt;params&gt;
    &lt;param&gt;
      &lt;value&gt;
        &lt;nil /&gt;
      &lt;/value&gt;
    &lt;/param&gt;
    &lt;param&gt;
      &lt;value&gt;
        &lt;nil /&gt;
      &lt;/value&gt;
    &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;
</pre>

<p>
A server method with the same signature will result in the &lt;nil&gt; parameter 
values each being passed into the method as null.
</p>

<h4>Method Return Value</h4>

<p>
A client method with its return type defined as either a reference type 
or a nullable value type will return null when it handles a response like this:
</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;methodResponse&gt;
  &lt;params&gt;
    &lt;param&gt;
      &lt;value&gt;
        &lt;nil /&gt;
      &lt;/value&gt;
    &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodResponse&gt;
</pre>

<p>
A server method defined as returning a reference type or a nullable value type 
will return a response with a &lt;nil&gt; as above if the method returns null.

Note that for backwards compatibility a server will return a dummy XML-RPC int value 
of zero for methods which are defined as returning void.
</p>


<h4>Struct Members</h4>

<p>
When converting a .NET struct or class to an XML-RPC struct the XmlRpcNullMapping 
attribute can be used to specify what should happen if a member's value is null. It's constructor
takes a value of NullMappingAction:
</p>

<pre>public enum NullMappingAction
{
Ignore = 0,
Error = 1,
Nil = 2,
}
</pre>

<p>
Ignore means that if the member's value is null the member should not be added to the 
XML-RPC struct; Error means that the member is not allowed to be null and an exception is thrown
if it is null; Nil means that the member should added to the XML-RPC struct with a value of 
&lt;nil&gt;. For example given struct:
</p>

<pre>
public struct TestStruct
{
  [XmlRpcMissingMapping(MappingAction.Ignore)]
  public int? x;
  [XmlRpcNullMapping(NullMappingAction.Error)]
  public int? y;
  [XmlRpcNullMapping(NullMappingAction.Nil)]
  public int? z;
}
</pre>

<p>
If x is null, y is 1 (a null value would throw an exception), and z is null, the corresponding 
XML-RPC struct would be:
</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;methodCall&gt;
  &lt;methodName&gt;MethodTakingTestStruct&lt;/methodName&gt;
  &lt;params&gt;
    &lt;param&gt;
      &lt;value&gt;
        &lt;struct&gt;
          &lt;member&gt;
            &lt;name&gt;y&lt;/name&gt;
            &lt;value&gt;
              &lt;i4&gt;1&lt;/i4&gt;
            &lt;/value&gt;
          &lt;/member&gt;
          &lt;member&gt;
            &lt;name&gt;z&lt;/name&gt;
            &lt;value&gt;
              &lt;nil /&gt;
            &lt;/value&gt;
          &lt;/member&gt;
        &lt;/struct&gt;
      &lt;/value&gt;
    &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;
</pre>

<p>
The default behaviour is that a member with a null value will be mapped onto &lt;nil&gt;.
</p>

<p>
When mapping an XML-RPC struct to a .NET struct or class, if a member in the XML-RPC struct is a 
&lt;nil&gt; value and the corresponding .NET member is a reference type or nullable value type the 
.NET member will be set to null. If the .NET member is a non-nullable reference type an exception
will be thrown.
</p>

<h3><a id="1.19"></a>1.19 Can .NET enum types be mapped to/from XML-RPC &lt;i4&gt; and &lt;i8&gt; values?</h3>

<p>
.NET enum type can be mapped to/from XML-RPC &lt;i4&gt; and &lt;i8&gt; values. The type of XML-RPC
value depends on the base type of the enum: enums with base type byte, sbyte, short, ushort, or int, 
are mapped to &lt;i4&gt;; whereas enums with base type uint or long are mapped to &lt;i8&gt;.
</p>

<p>
Enums with base type ulong are not supported because ulong cannot be represented by &lt;i8&gt;.
</p>


<h2>2. Clients</h2>


<h3><a id="2.1"></a>2.1 How do I implement an XML-RPC client?</h3>


<p>
To make calls to an XML-RPC server it is necessary to use an instance of a proxy class. 
</p>

<p>
First devise an interface which represents the methods of XML-RPC server 
endpoint and derive it from IXmlRpcProxy. Mark each of the methods representing
an XML-RPC method call with the XmlRpcMethod attribute. For example:
</p>

<pre>using CookComputing.XmlRpc;

public struct SumAndDiffValue 
{
  public int sum; 
  public int difference; 
}

[XmlRpcUrl("http://www.cookcomputing.com/sumAndDiff.rem")] 
public interface ISumAndDiff : IXmlRpcProxy
{ 
  [XmlRpcMethod] 
  SumAndDiffValue SumAndDifference(int x, int y);
} 
</pre>

<p>
Note: IXmlRpcProxy was introduced in version 1.0 of XML-RPC.NET. Before then
it was necessary to cast the proxy to XmlRpcClientProtocol and then set the 
required properties. Interfaces which don't derive from IXmlRpcProxy
can still be used although casting will still be required.
</p>


<p>
Second, create an instance of a dynamically created proxy class:
</p>

<pre>ISumAndDiff proxy = XmlRpcProxyGen.Create&lt;ISumAndDiff&gt;();
</pre>

<p>
Third, call a method on the interface:
</p>

<pre>SumAndDiffValue ret = proxy.SumAndDifference(2, 3);</pre>

<h3><a id="2.2"></a>2.2 What if the XML-RPC method name is not valid in my programming language?</h3>

<p>
Sometimes the XML-RPC method name cannot be used as a method name in the proxy 
class. For example, it is common practice for XML-RPC method names to have the 
form <i>namespace.methodname</i>, such as <i>sample.SumAndDifference</i> In 
these cases a different constructor is used for the XmlRpcMethod attribute, 
taking a string which specifies the XML-RPC method name. For example:
</p>

<pre>[XmlRpcUrl("http://www.cookcomputing.com/sumAndDiff.rem")] 
public interface ISumAndDiff : IXmlRpcProxy
{ 
  [XmlRpcMethod("sample.sumAndDifference")]  
  SumAndDiffValue SumAndDifference(int x, int y);
} 

</pre>


<h3><a id="2.3"></a>2.3 Can I specify the server endpoint URL at runtime?</h3>

<p>
Yes, proxy classes are derived from IXmlRpcProxy and so inherit a Url 
property. This means that the XmlRpcUrl attribute can be omitted from the 
definition of the proxy class and instead the Url property is then set on 
an instance of the proxy class:
</p>

<pre>ISumAndDiff proxy = XmlRpcProxyGen.Create&lt;ISumAndDiff&gt;();
proxy.Url = &quot;http://www.cookcomputing.com/SumAndDiff.rem&quot;;
SumAndDiffValue ret = proxy.SumAndDifference(2, 3);
</pre>

<p>
The port connected to will default to 80 for a http Url and 443 for a https 
Url. To use a different port add ':' followed by the port number to the host
name. For example:
</p>

<pre>proxy.Url = &quot;http://www.cookcomputing.com:8080/SumAndDiff.rem&quot;;
</pre>


<h3><a id="2.4"></a>2.4 How do I set a timeout on a proxy method call?</h3>

<p>
Proxy classes are derived from IXmlRpcProxy and so inherit a Timeout property. This 
takes an integer which specifies the timeout in milliseconds. For example, to 
set a 5 second timeout:
</p>


<pre>ISumAndDiff proxy = XmlRpcProxyGen.Create&lt;ISumAndDiff&gt;();
proxy.Timeout = 5000;
SumAndDiffValue ret = proxy.SumAndDifference(2, 3);</pre>


<h3><a id="2.5"></a>2.5 How do I supply authentication credentials?</h3>

<p>
Proxy classes are derived from IXmlRpcProxy and so inherit a Credentials 
property. This is used where the XML-RPC server authenticates the caller. 
The property is used in exactly the same way as the same property of the 
System.Net.WebRequest class. For example:
</p>

<pre>ISumAndDiff proxy = XmlRpcProxyGen.Create&lt;ISumAndDiff&gt;();
proxy.Credentials = new NetworkCredential("jsmith","password");
SumAndDiffValue ret = proxy.SumAndDifference(2, 3);
</pre>


<h3><a id="2.6"></a>2.6 Can I specify custom HTTP headers? </h3>

<p>
Yes, proxy classes are derived from IXmlRpcProxy and so inherit a Headers 
property of type WebHeaderCollection. This can be used to specify custom 
headers which will be added to the HTTP request. For example:
</p>

<pre>ISumAndDiff proxy = XmlRpcProxyGen.Create&lt;ISumAndDiff&gt;();
proxy.Headers.Add("TestHeader", "this_is_a_test");
SumAndDiffValue ret = proxy->SumAndDifference(2, 3);
</pre>


<h3><a id="2.7"></a>2.7 How do I send cookies with a request?</h3>

<p>
Proxy classes are derived from IXmlRpcProxy and so inherit a CookieContainer 
property of type System.Net.CookieContainer, like the corresponding property of 
System.Net.HttpWebRequest. Instances of System.Net.Cookie added to the container 
will sent with the HTTP request. For example:
</p>

<pre>ISumAndDiff proxy = XmlRpcProxyGen.Create&lt;ISumAndDiff&gt;();
Cookie cookie = new Cookie("foo", "bar", "/", "www.cookcomputing.com")
proxy.CookieContainer.Add(cookie);
SumAndDiffValue ret = proxy->SumAndDifference(2, 3);
</pre>


<h3><a id="2.8"></a>2.8 How do I make an asynchronous XML-RPC request?</h3>

<p>
Although XML-RPC itself only supports synchronous method calls, XML-RPC.NET 
has support for asynchronous calls on proxy classes. </p>

<p>
There are two ways of handling asynchronous calls: polling to determine when 
the call has completed, and using a delegate to receive a callback when the 
call has completed.These are discussed in the following answers.
</p>

<p>
The interface which represents the methods of XML-RPC server endpoint is extended 
with Begin and End methods for each XML-RPC method to be called asynchronously. 
Two attributes are used for this, the XmlRpcBeginAttribute, which is used to 
indicate which methods used to start async calls, and the XmlRpcEndAttribute, 
which is used to indicate methods which end async calls. For example:
</p>

<pre>using CookComputing.XmlRpc;

struct SumAndDiffValue 
{
  public int sum; 
  public int difference; 
}

[XmlRpcUrl("http://www.cookcomputing.com/sumAndDiff.rem")] 
public interface ISumAndDiff : IXmlRpcProxy
{ 
  [XmlRpcMethod] 
  SumAndDiffValue SumAndDifference(int x, int y);
  
  [XmlRpcBegin]
  IAsyncResult BeginSumAndDifference(int x, int y);

  [XmlRpcBegin]
  IAsyncResult BeginSumAndDifference(int x, int y, AsyncCallback acb);

  [XmlRpcBegin]
  IAsyncResult BeginSumAndDifference(int x, int y, AsyncCallback acb,
    object state);

  [XmlRpcEnd]
  SumAndDiffValue EndSumAndDifference(IAsyncResult iasr);
} </pre>

<p>
The name of each Begin method is the name of the XML-RPC method name prefixed 
by &quot;Begin&quot;: the XML-RPC.NET runtime code strips off the &quot;Begin&quot; 
to determine the name of the XML-RPC method to be called. In the case where 
the XML-RPC method name prefixed by &quot;Begin&quot; is not suitable, a different 
XmlRpcBeginAttribute constructor can be used to specify the XML-RPC method name. 
For example:
</p>

<pre>  [XmlRpcBegin(&quot;sample.sumAndDifference&quot;)] 
  IAsyncResult BeginSumAndDifference(int x, int y); 
</pre>

<p>
The name of each End method is not used in the same way - all that matters 
is that the parameter is IAsyncResult and the return value represents the return 
value of the corresponding XML-RPC method. However it is worth following following 
the convention that the name is similar to the name of the corresponding Being 
method, with &quot;End&quot; replacing the &quot;Being&quot; prefix.
</p>

<p>Where a callback is required when the method completes it is necessary to pass 
a callback delegate to the method. 
</p>

<pre>[XmlRpcBegin] 
IAsyncResult BeginSumAndDifference(int x, int y, AsyncCallback acb); 
</pre>

<p>
The AsyncCallback parameter must follow all the normal parameters to the method. 
Finally, where some state is required to be held during the async call, for 
example where the same callback delegate is being used to handle multiple calls 
and the target of the delegate has to distinguish between calls, another parameter 
can be specified to pass the state into the call. This is of type System.Object 
and must follow the AsyncCallback parameter, for example:
</p>

<pre>  [XmlRpcBegin] 
  IAsyncResult BeginSumAndDifference(int x, int y, AsyncCallback acb, 
    object state); 
</pre>

<p>
If a proxy async method has been defined with the AsyncCallback parameter and/or 
the state parameter and they are not required in a call they can be passed as 
null. 
</p>


<h3><a id="2.9"></a>2.9 How do I poll for the result of an asynchronous call?</h3>

<p>
When polling the last two parameters of BeginSumAndDifference are not required 
and can be passed as null. The asynchronous call would begin like this: 
</p>

<pre>IAsyncResult asr;<br/>asr = proxy.BeginSumAndDifference(5, 3, null, null); </pre>

<p>
An instance of the IAsyncResult is returned. This has several public properties, 
the interesting one for polling being the boolean property IsCompleted. The 
value of this property can be checked as required until is found to be true, 
for example: 
</p>

<pre>while (asr.IsCompleted == false) 
{ 
  Thread.Sleep(1000); 
} </pre>

<p>
Once the call has completed the result of the call can be obtained by calling 
EndSumAndDifference, passing in the instance of IAsyncResult returned from the 
call to BeginSumAndDifference: 
</p>

<pre>try 
{ 
  Result ret = theProxy.EndSumAndDifference(asr); 
} 
catch(Exception ex) 
{ 
  // handle the exception 
} </pre>

<p>
Note that a try-catch block is placed around the call to EndSumAndDifference. 
This is because any exceptions thrown during the asynchronous processing of 
the call, for example a network error or because the server returned a Fault 
Response, are stored until the XmlRpcClientProtocol method EndInvoke is called, 
at which point the the exception is rethrown. 
</p>


<h3><a id="2.10"></a>2.10 How do I receive a callback on completion of an asynchronous call?</h3>

<p>
When a callback approach is used, a method must be defined and used with a 
delegate to take the callback:
</p>

<pre>void SumAndDiffCallback(IAsyncResult asr) 
{ 
  XmlRpcAsyncResult clientResult = (XmlRpcAsyncResult)asr;
  ISumAndDiff proxy = (ISumAndDiff)clientResult.ClientProtocol;
  try 
  { 
    Result ret = proxy.EndSumAndDifference(asr); 
  } 
  catch(Exception ex) 
  { 
    // handle the exception 
  } 
} </pre>

<p>
This time when calling BeginSumAndDifference an AsyncCallback delegete must 
be created and passed into the call:
</p>

<pre>theProxy.BeginSumAndDifference(5, 3, SumAndDiffCallback, theProxy); </pre>

<p>
The IAsyncResult returned from the call is ignored because all further handling 
of the call is done via the callback. When the call is completed, the callback 
method is called and, as its implementation suggests, the original SumAndDiffProxy 
used to make the call is retrieved from XmlRpcAsyncResult instance (cast 
to this from the IAsyncResult interface) interface so that the 
EndSumAndDifference method can be called to retrieve the result. 
</p>

<h3><a id="2.11"></a>2.11 What is the asyncState parameter used for?</h3>

<p>
The fourth parameter to BeginInvoke and the proxy methods that call this method 
is an object which can optionally be used to hold some state during the lifetime 
of the asynchronous call. In many cases this will be unnecessary and can be 
passed as null.
</p>


<h3><a id="2.12"></a>2.12 How do I implement a client in VB.NET?</h3>

<p>
The client implemented in C# in section 2.1 can be implemented similarly in 
  VB.NET: 
</p>

<pre>Imports CookComputing.XmlRpc

Public Structure SumAndDiffValue
  Public sum As Integer
  Public difference As Integer
End Structure

&lt;XmlRpcUrl(&quot;http://www.cookcomputing.com/sumAndDiff.rem&quot;)&gt; _
Public Interface SumAndDiffItf 
  Inherits IXmlRpcProxy
  &lt;XmlRpcMethod(&quot;sample.sumAndDifference&quot;)&gt; _
  Function SumAndDifference(ByVal x As Integer, _
                            ByVal y As Integer) _
                            As SumAndDiffValue
End Interface

Module SumAndDiffVB
  Sub Main()
    Dim proxy As SumAndDiffItf
    proxy = CType(XmlRpcProxyGen.Create(GetType(SumAndDiffItf)), SumAndDiffItf)
    Dim ret As SumAndDiffValue
    ret = proxy.SumAndDifference(2, 3)
    Console.WriteLine("sum = {0}  diff = {1}", ret.sum, ret.difference)
    End Sub
End Module
</pre>

<p>
Remember to add a reference to CookComputing.XmlRpcV2.dll to your project. 
</p>

<h3><a id="2.13"></a>2.13 Why does the following VB code cause an exception?</h3>

<p>
When using arrays in VB the following mistake is easy to make and will cause 
an exception at runtime:
</p>

<pre>XmlRpcMethod(&quot;db.listCollections&quot;)_
Public Function listCollections(ByVal name As String) As String()
  Dim coll() As String = {}
  Dim param(1) As Object
  param(0) = New String(name)
  coll = Invoke(&quot;listCollections&quot;, param)
  Return coll
End Function</pre>

<p>
The line defining param actually defines an array with two elements, the first 
element being the required string, the second element being null. It should 
be correctly coded as:
</p>

<pre>Dim param(0) As Object</pre>


<h3><a id="2.14"></a>2.14 How do I implement a client in Managed C++?</h3>

<p>
<i>TBD</i>
</p>


<h3><a id="2.15"></a>2.15 How do I implement a client in JScript.NET?</h3>

<p>
<i>TBD</i>
</p>


<h3><a id="2.16"></a>2.16 Do proxies support the Introspection API?</h3>

<p>
Yes, support for the XML-RPC Introspection API is built into proxies. 
Any class derived from XmlRpcClientProtocol or just an instance of XmlRpcClientProtocol 
can be used to make Introspection requests. 
</p>

<p>
Three public methods expose the three methods of the API: 
</p>
<ul>
  <li>System.String[] SystemListMethods() </li>
  <li>System.Object[] SystemMethodSignature(System.String MethodName)</li>
  <li>System.String SystemMethodHelp(System.String MethodName) </li>
</ul>

<p>
SystemListMethods is used to call the system.listMethods method on the server. 
It simply returns an array of strings containing the XML-RPC names of the methods 
supported by this endpoint on the server.
</p>

<pre>string[] methods = proxy.ListMethods();</pre>

<p>
SystemMethodSignature is used to call the system.methodSignature method on 
the server. It returns an array of Object, each member of the array being an 
instance of an array of strings. This could have been represented more accurately 
as a jagged array - System.String[][] - but jagged arrays are not CLS compliant. 
</p>

<pre>object[] signatures = proxy.SystemMethodSignature("sample.sumAndDifference"); 
foreach (string[] signature in signatures) 
  foreach (string param in signature)<br/>  	Console.WriteLine(param); 
</pre>

<p>
Finally, SystemMethodHelp calls the system.methodHelp method on the server 
and returns a help string for the specified method.
</p>

<pre>string s = proxy.SystemMethodHelp("sample.sumAndDifference");
</pre>


<h3><a id="2.17"></a>2.17 Can I define a proxy method to return void?</h3>

<p>
XML-RPC methods must always return a value. However there are some situations 
in which an XML-RPC method would have been defined to return void if this were 
possible and in these cases a dummy value may be returned, for example an empty 
string. The proxy method could be defined to return a corresponding type but 
it is perhaps more clear to specify the method as returning void, in which case 
the dummy return value is discarded. For example:
</p>

<pre>[XmlRpcMethod] 
void SumAndDifference(int x, int y);
</pre>


<h3><a id="2.18"></a>2.18 How do I specify a proxy server when making an XML-RPC request?</h3>

<p>
Sometimes the XML-RPC client is behind a firewall and must send requests via 
a proxy server. There are two methods of achieving this with XML-RPC.NET. 
</p>

<p>The first method is to set the Proxy property of the proxy class. In a similar 
way to setting the Proxy property of an instance of class System.Net.WebRequest, 
the property is set to an instance of the IWebProxy interface, this usually 
being the interface on an instance of the System.Net.WebProxy class. For example:
</p>

<pre>ISumAndDiff proxy = XmlRpcProxyGen.Create&lt;ISumAndDiff&gt;();
proxy.Proxy = new WebProxy(&quot;http://proxyserver:8000&quot;);    
SumAndDiffValue ret = proxy.SumAndDifference(2, 3); </pre>

<p>The second method is to set a global default proxy for all requests by using 
the System.Net.GlobalProxySelection class:
</p>

<pre>GlobalProxySelection.Select = &quot;http://proxyserver:8000&quot;;</pre>


<h3><a id="2.19"></a>2.19 Is a client proxy thread-safe?</h3>

<p>
The thread safety of a proxy is essentially the same as that of
the underlying System.Net.WebRequest object:
</p>

<blockquote>
<p>
"Any public static (Shared in Visual Basic) members of this type are thread
safe. Any instance members are not guaranteed to be thread safe."
</p>
</blockquote>

<p>
If you need to make concurrent calls, use a separate proxy for each call. Note that
it is ok to make multiple calls to XmlRpcProxyGen.Create for the same type 
because the dynamically generated proxy class is cached and reused in following 
calls to Create.
</p>


<h3><a id="2.20"></a>2.20 How do I call an XML-RPC method with a variable number of parameters?</h3>

<p>
The params keyword can be used to call an XML-RPC method which take a variable number 
of parameters. For example, if an XML-RPC method takes a variable number number
of integer parameters it could be defined like this:
</p>

<pre>[XmlRpcUrl("http://www.cookcomputing.com/notimpl.rem")] 
public interface IParams : IXmlRpcProxy
{ 
  [XmlRpcMethod] 
  int UseNumbers(params int[] numbers);
} 
</pre>

<p>
And called like this:
</p>

<pre>IFoo proxy = XmlRpcProxyGen.Create&lt;IFoo&gt;();
proxy.SendMultipleParameters(1);
proxy.SendMultipleParameters(1, 2, 3);
</pre>

<p>
The resulting XML-RPC requests would look like this:
</p>

<pre><?xml version="1.0"?>
&lt;methodCall&gt;
  &lt;methodName&gt;SendMultipleParameters&lt;/methodName&gt;
  &lt;params&gt;
    &lt;param&gt;
      &lt;value&gt;
        &lt;i4&gt;1&lt;/i4&gt;
      &lt;/value&gt;
    &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;

<?xml version="1.0"?>
&lt;methodCall&gt;
  &lt;methodName&gt;SendMultipleParameters&lt;/methodName&gt;
  &lt;params&gt;
    &lt;param&gt;
      &lt;value&gt;
        &lt;i4&gt;1&lt;/i4&gt;
      &lt;/value&gt;
    &lt;/param&gt;
    &lt;param&gt;
      &lt;value&gt;
        &lt;i4&gt;2&lt;/i4&gt;
      &lt;/value&gt;
    &lt;/param&gt;
    &lt;param&gt;
      &lt;value&gt;
        &lt;i4&gt;3&lt;/i4&gt;
      &lt;/value&gt;
    &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;
</pre>

<p>
Alternatively the parameters in this example can be supplied as an array of type int[]:
</p>

<pre>int[] parameters = new int[] { 1, 2, 3 };
proxy.SendMultipleParameters(parameters);
</pre>

<p>
Where the parameters are not of the same type it is necessary to define the 
params array as having type object[], for example:
</p>

<pre>[XmlRpcUrl("http://www.cookcomputing.com/notimpl.rem")] 
public interface IParams : IXmlRpcProxy
{ 
  [XmlRpcMethod] 
  int UseParameters(params object[] parameters);
} 
</pre>

<h3><a id="2.21"></a>2.21 Can I configure the use of &lt;int&gt; instead of &lt;i4&gt;?</h3>

<p>
When XML-RPC.NET generates an XML-RPC request containing integer values, 
by default it uses the &lt;i4&gt; tag instead of the &lt;int&gt; tag for integers.
Both tags are valid XML-RPC but some other XML-RPC server implementations do
not support the &lt;i4&gt; form. If this is the case, the UseIntTag property of 
IXmlRpcProxy can be used to configure the use of &lt;int&gt;, for example:
</p>

<pre>ISumAndDiff proxy = XmlRpcProxyGen.Create&lt;ISumAndDiff&gt;();
proxy.UseIntTag = true;
</pre>


<h3><a id="2.22"></a>2.22 Does XML-RPC.NET accept non-standard XML-RPC responses?</h3>

<p>
Some XML-RPC server implementations return XML-RPC responses which do not comply 
with the XML-RPC specification. The XmlRpcClientProtocol class has a property called
NonStandard which can be set to one of or a combination of the flags in the 
XmlRpcNonStandard enumeration:
</p>

<pre>[Flags]
public enum XmlRpcNonStandard
{
    None = 0x00,
    AllowStringFaultCode = 0x01,
    AllowNonStandardDateTime = 0x02,
    IgnoreDuplicateMembers = 0x4,
    MapZerosDateTimeToMinValue = 0x8,
    MapEmptyDateTimeToMinValue = 0x10,
    AllowInvalidHttpContent = 0x20;
    All = 0x7fff,
}
</pre>

The flags have the following effect:
<ul>
<li>
AllowStringFaultCode - the FaultCode in a fault response should be an integer but 
some servers return it as a string. This flag is used to indicate that a string is
acceptable and should be converted into an integer.
</li>
<li>
AllowNonStandardDateTime - deprecated - the following examples 
illustrate the formats which are accepted by default with the '-' and 
':' separators being optional (the XML-RPC spec describes the format as 
19980717T14:08:55 but it's unclear whether this is an example of an ISO 8601 
date/time format or a specification):
<ul>
<li>
1998-07-17T14:08:55 
</li>
<li>
1998-07-17T14:08:55Z 
</li>
<li>
1998-07-17T14:08:55+01 
</li>
<li>
1998-07-17T14:08:55+0100 
</li>
</ul>
</li>
<li>
IgnoreDuplicateMembers - some servers return XML-RPC struct with two or more
members with the same name. This flag is used to indicate that the value of
the first member with the same name should be used and subsequent duplicate
members are to be ignored.
</li>
<li>
MapZerosDateTimeToMinValue - some servers use a dateTime value containing all
zeros to indicate a "null" value, i.e. 00000000T00:00:00. By default this will
cause an exception to be thrown but if this flag is set all-zeroes dateTime 
values will be mapped onto System.DateTime.MinValue.
</li>
<li>
MapEmptyDateTimeToMinValue - some servers use an dateTime value to indicate 
a "null" value, i.e. 00000000T00:00:00. By default this will
cause an exception to be thrown but if this flag is set empty dateTime 
values will be mapped onto System.DateTime.MinValue.
</li>
<li>
AllowInvalidHttpContent - some servers return HTTP content which contains 
whitespace/blanklines before the start of the XML response document. 
Normally this would cause an XmlRpcIllFormedXmlException to be thrown. This 
flag specifies that any leading whitespace should be ignored.
</li>
</ul>

<p>
For example: 
</p>

<pre>ISumAndDiff proxy = XmlRpcProxyGen.Create&lt;ISumAndDiff&gt;();
proxy.NonStandard = XmlRpcNonStandard.AllowStringFaultCode
                    & XmlRpcNonStandard.IgnoreDuplicateMembers;
</pre>


<h3><a id="2.23"></a>2.23 Can I configure method names at runtime?</h3>

<p>
The method name used when making an XML-RPC request is statically 
defined by the associated method's name in the interface or class 
used to create the proxy. However, there are some XML-RPC APIs which 
require the method name to be generated dynamically at runtime, for 
example to prefix the method name with a session id. In this 
infrequent situation the XmlRpcMethod property of IXmlRpcProxy
can be used to override the statically defined method name before a 
request is made. In this example the method name sent in the XML-RPC
request will be &quot;Id1234_SumAndDifference&quot; instead of the 
statically defined &quot;SumAndDifference&quot;
</p>

<pre>ISumAndDiff proxy = XmlRpcProxyGen.Create&lt;ISumAndDiff&gt;);
proxy.XmlRpcMethod = &quot;Id1234_SumAndDifference&quot;
proxy.SumAndDifference(3, 4);
</pre>


<h3><a id="2.24"></a>2.24 What is the Expect100Continue property used for?</h3>

<p>
If the Expect100Continue property on proxies is set to true, 
the header "Expect: 100-Continue" is set on each XML-RPC request. According to
the HTTP 1.1 protocol, when this header is sent the server immediately responds 
with a response with the status "100 Continue". This allows the client to 
determine that the connection to the server has succeeded before it sends the
body of the request. The client waits in the order of hundreds of milliseconds
for the "100 Continue" response. The idea behind this is that POST requests
may not be idempotent and a client cannot resend the data if error occurs
after it has started sending the data in the body of the request. Ensuring that
a response has been received before sending the data reduces the chance that 
the server receives only part of the data.
</p>

<p>
The Expect100Continue property defaults to false, i.e. the 
"Expect: 100-Continue" header is not sent. There have been several reports of 
XML-RPC servers which cannot handle this header and anyway it does not serve 
any real purpose in the context of XML-RPC. If the server receives only part
of the request then it will fail to parse the XML-RPC request and will return
an error. Futhermore use of the header results in each XML-RPC request taking 
hundreds of milliseconds longer than without the header.
</p>


<h3><a id="2.25"></a>2.25 What is the KeepAlive property used for?</h3>

<p>
The KeepAlive proxy property determines whether the connection to the server
is kept open after the initial connection (assuming the server supports this). 
The default value is true, keeping the connection open, but in some cases it 
may be necessary to set it to false. An example of this is where the server 
sends spurious bytes after the end of the XML-RPC response which means that 
XML-RPC.NET reads these bytes as if they are at the beginning of the next
response and so throws an exception whose message is "The server committed 
a protocol violation. Section=ResponseStatusLine".
</p>


<h3><a id="2.26"></a>2.26 Why does XML-RPC.NET throw XmlRpcIllFormedXmlException?</h3>

<p>
If your code makes a call on a proxy and an XmlRpcIllFormedXmlException is 
thrown with the message "Response from server does not contain valid XML." 
it means that the XML-RPC response from the server cannot be parsed as a valid
XML document (parsing is performed by the .NET XmlDocument class). It is not a
problem with the client. See section <a href="#5.1">5.1</a> on how to 
investigate what the server is sending across the network.
</p>

<p>
Section <a href="#2.22">2.22</a> describes the AllowInvalidHttpContent flag 
which can be used to prevent the XmlRpcIllFormedXmlException exception in 
some circumstances.
</p>


<h3><a id="2.27"></a>2.27 How can I stop a WebException being thrown?</h3>

<h4>The Underlying Connection Was Closed</h4>

<p>
When an instance of WebException is thrown with this message "The underlying connection was closed: A
connection that was expected to be kept alive was closed by the server", try
setting the KeepAlive property on the proxy to false. </p>


<h4>Protocol Violation</h4>

<p>
One of the issues involving XML-RPC.NET that turns up fairly frequently is 
when the library throws an instance of System.Net.WebException with the 
message "The server committed a protocol violation". This usually occurs 
because from .NET 1.1 SP1 onwards the parsing of HTTP responses became much 
more strict, as a security measure to prevent attacks which exploit malformed 
HTTP status lines and headers. The strict behaviour can be switched off 
via the application config file (or similarly with the web config file):
</p>

<pre>&lt;?xml version ="1.0"?&gt;
&lt;configuration&gt;
  &lt;system.net&gt;
    &lt;settings&gt;
      &lt;httpWebRequest useUnsafeHeaderParsing="true" /&gt;
    &lt;/settings&gt;
  &lt;/system.net&gt;
&lt;/configuration&gt;
</pre>

<p>
From .NET 2.0 this configuration property can be set programmatically using the 
HttpWebRequestElement useUnsafeHeaderParsing property. This is used 
in the 2.0 configuration infrastructure to set the value in the config file. 
Once you do this the new value applies to the current running application as 
well as any instances launched afterwards. The property can be used like this:
</p>

<pre>Configuration config = ConfigurationManager.OpenExeConfiguration(
  ConfigurationUserLevel.None);
SettingsSection section = (SettingsSection)config.GetSection(
  "system.net/settings");
section.HttpWebRequest.UseUnsafeHeaderParsing = true;
config.Save();
</pre>

<p>
ConfigurationUserLevel.None specifies that the configuration file in the same 
directory as the executable should be modified so this file has to be writable. 
The other options PerUserRoaming and PerUserRoamingAndLocal can be used in 
different scenarios.
</p>

<p>
Finally, the following code can be used with the .NET 2.0 runtime if you don't
want to use the config file. It uses reflection to set the private field 
useUnsafeHeaderParsing to true and so may not be suitable in all scenarios 
where the relevant code access security permission is not available. 
(Note: add System.Configuration.dll as a reference to your project.)
</p>

<pre>public static bool SetAllowUnsafeHeaderParsing()
{
  //Get the assembly that contains the internal class
  Assembly aNetAssembly = Assembly.GetAssembly(
    typeof(System.Net.Configuration.SettingsSection));
  if (aNetAssembly != null)
  {
    //Use the assembly in order to get the internal type for 
    // the internal class
    Type aSettingsType = aNetAssembly.GetType(
      "System.Net.Configuration.SettingsSectionInternal");
    if (aSettingsType != null)
    {
      //Use the internal static property to get an instance 
      // of the internal settings class. If the static instance 
      // isn't created allready the property will create it for us.
      object anInstance = aSettingsType.InvokeMember("Section",
        BindingFlags.Static | BindingFlags.GetProperty 
        | BindingFlags.NonPublic, null, null, new object[] { });
      if (anInstance != null)
      {
        //Locate the private bool field that tells the 
        // framework is unsafe header parsing should be 
        // allowed or not
        FieldInfo aUseUnsafeHeaderParsing = aSettingsType.GetField(
          "useUnsafeHeaderParsing", 
          BindingFlags.NonPublic | BindingFlags.Instance);
        if (aUseUnsafeHeaderParsing != null)
        {
          aUseUnsafeHeaderParsing.SetValue(anInstance, true);
          return true;
        }
      }
    }
  }
  return false;
}
</pre>


<h3><a id="2.28"></a>2.28 Can a proxy interface contain overloaded methods?</h3>

<p>
An interface can contain overloaded methods: methods with the same name but with
with different parameter signatures. For example:
</p>

<pre>[XmlRpcUrl("http://www.cookcomputing.com/sumAndDiff.rem")] 
public interface ISumAndDiff
{ 
  [XmlRpcMethod] 
  SumAndDiffValue SumAndDifference(int x, int y);
  [XmlRpcMethod] 
  SumAndDiffValue SumAndDifference(string x, string y);
} 
</pre>

<p>
Note that in this example, the server must be able to handle either two 
integers or two strings as the method parameters for its SumAndDifference
method. If it is implemented using XML-RPC.NET then the .NET parameters in the 
server implementation should be declared as type object so that the actual 
type of the parameters sent by the client can be determined at runtime.
</p>


<h3><a id="2.29"></a>2.29 How Do I Implement a Client in Boo?</h3>

<p>
This sample implements a simple client in the 
<a href="http://boo.codehaus.org/">Boo</a> programming language:
</p>

<pre>
import System
import CookComputing.XmlRpc from CookComputing.XmlRpc

[XmlRpcUrl("http://www.cookcomputing.com/xmlrpcsamples/RPC2.ashx")]
interface IStateName:
        [XmlRpcMethod("examples.getStateName")]
        def GetName(num as int) as string

obj as IStateName = XmlRpcProxyGen.Create(typeof(IStateName))
Console.WriteLine(obj.GetName(1))
</pre>

<h3><a id="2.30"></a>2.30 Can I configure the client to not use the &lt;string&gt; tag?</h3>

<p>
When XML-RPC.NET generates an XML-RPC request containing string values, 
by default it uses the &lt;string&gt; tag for string values. However this is 
not required by the XML-RPC standard: it is possible to just include the text 
of the string as a child of the outer &lt;value&gt; tag. To configure the 
client to not use the &lt;string&gt; tag, the UseStringTag property of 
IXmlRpcProxy can be used, for example:
</p>

<pre>ISumAndDiff proxy = XmlRpcProxyGen.Create&lt;ISumAndDiff&gt;();
proxy.UseStringTag = false;
</pre>


<h3><a id="2.31"></a>2.31 How do I configure client support for Accept-Encoding?</h3>
<p>
Some servers may support compression of XML-RPC responses. The client indicates 
that it can accept a compressed response by setting the 
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3">
HTTP Accept-Encoding</a> header:
</p>

<pre>ISumAndDiff proxy = XmlRpcProxyGen.Create&lt;ISumAndDiff&gt;();
proxy.EnableCompression = true;
</pre>

<p>
The content-codings <b>compress</b> and <b>gzip</b> are supported.
</p>

<h3><a id="2.32"></a>2.32 How do I prevent an empty params element in a request?</h3>
<p>
The XML-RPC spec is unclear about what should be sent in a request if the 
method call does not take any parameters. By default XML-RPC.NET sends an empty
params element:
</p>

<pre>&lt;?xml version=""1.0""?&gt;
&lt;methodCall&gt;
  &lt;methodName&gt;Foo&lt;/methodName&gt;
  &lt;params /&gt;
&lt;/methodCall&gt;
</pre>

<p>
However, some servers expect the params element not to be sent if there are no
parameters:
</p>

<pre>&lt;?xml version=""1.0""?&gt;
&lt;methodCall&gt;
  &lt;methodName&gt;Foo&lt;/methodName&gt;
&lt;/methodCall&gt;
</pre>

<p>
To support these servers, set the UseEmptyParamsTag property of IXmlRpcProxy 
to false (the default is true):
</p>

<pre>ISumAndDiff proxy = XmlRpcProxyGen.Create&lt;ISumAndDiff&gt;();
proxy.UseEmptyParamsTag = false;
</pre>


<h3><a id="2.33"></a>2.33 Can I retrieve the HTML response headers and cookies?</h3>
<p>
To retrieve the HTML response headers and cookies, use the ResponseHeaders and 
ResponseCookies properties of IXmlRpcProxy. For example, assuming the proxy 
interface ISumAndDiff is derived from IXmlRpcProxy (which is recommended):
</p>

<pre>ISumAndDiff proxy = XmlRpcProxyGen.Create&lt;ISumAndDiff&gt;();
SumAndDiffValue ret = proxy.SumAndDifference(2, 3);
WebHeaderCollection headers = proxy.ResponseHeaders;
CookieCollection cookies = proxy.ResponseCookies; 
</pre>

<p>
The response headers and cookies retrieved are those associated with the last 
call made by the proxy. When making an asynchronous call the headers and 
cookies can be retrieved as follows:
</p>

<pre>Result ret = theProxy.EndSumAndDifference(asr); 
WebHeaderCollection headers = ((XmlRpcAsyncResult)iasr).ResponseHeaders;
CookieCollection cookies = ((XmlRpcAsyncResult)iasr).ResponseCookies;
</pre>


<h3><a id="2.34"></a>2.34 How do I call an XML-RPC method which requires named parameters in a struct?</h3>
<p>
Some XML-RPC APIs use a struct as a single parameter to methods, so that the 
members of the struct acts as named parameters to the method. For example,
the <a href="http://www.last.fm/api">Last.fm API</a> has a method called
"artist.getInfo" which has two named parameters, "artist" and "api_key". 
The XML-RPC request XML for this method looks like this example:
</p>
<pre>&lt;?xml version=""1.0""?&gt;
&lt;methodCall&gt;
  &lt;methodName&gt;artist.getInfo&lt;/methodName&gt;
  &lt;params&gt;
    &lt;param&gt;
      &lt;value&gt;
        &lt;struct&gt;
          &lt;member&gt;
            &lt;name&gt;artist&lt;/name&gt;
            &lt;value&gt;
              &lt;string&gt;Bob Dylan&lt;/string&gt;
            &lt;/value&gt;
          &lt;/member&gt;
          &lt;member&gt;
            &lt;name&gt;api_key&lt;/name&gt;
            &lt;value&gt;
              &lt;string&gt;abcd1234&lt;/string&gt;
            &lt;/value&gt;
          &lt;/member&gt;
        &lt;/struct&gt;
      &lt;/value&gt;
    &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;
</pre>

<p>
This could be implemented in XML-RPC.NET by using a struct 
parameter but the StructParams attribute allows the method to 
be defined using multiple parameters which are automatically
mapped to an XML-RPC struct at runtime, the names of the method
parameters in the interface definition being used as the
names of the members in the XML-RPC struct. For example, 
"artist.getInfo" could be defined like this: 
</p>

<pre>
public interface ILastFM : IXmlRpcProxy
{ 
    // ...

    [XmlRpcMethod("artist.getInfo", StructParams = true)]
    public string getInfo(string artist, string api_key);

    // ...
}
</pre>


<h3><a id="2.35"></a>2.35 Can I use the NonSerialized attribute on struct members?</h3>
<p>
Yes, the System.NonSerialized attribute can be used to prevent a struct member 
being serialized or deserialized. For example instances of the following struct will
only have the member "x" serialized into the XML-RPC struct:
</p>

<pre>struct MyStruct
{
  public int x;
  [NonSerialized]
  public int y;
}    
</pre>



<h2>3. Servers</h2>

<h3><a id="3.1"></a>3.1 What are the different ways in which an XML-RPC server can be implemented?</h3>

<p>
There are three ways of implementing an XML-RPC server using XML-RPC.NET:
</p>

<ol>
  <li>In IIS using a class derived from XmlRpcService.</li>
  <li>Using an XML-RPC formatter with .NET Remoting.</li>
  <li>In IIS using an XML-RPC formatter with .NET Remoting.</li>
</ol>


<h3><a id="3.2"></a>3.2 How do I implement an XML-RPC server in IIS?</h3>

<p>
Class XmlRpcService implements an HTTP Handler which exposes the IHttpHandler 
and IRequiresSessionState interfaces. When a class derived from XmlRpcService 
is configured via a web.config file, incoming XML-RPC requests will be directed 
to the handler by the ASP.NET runtime. 
</p>

<h4>Implementing the Service</h4>

<p>
XmlRpcService is derived from, adding the custom application function of the 
Service. The derived class contains one or more public methods which represent 
the required XML-RPC methods. For example, the SumAndDifference example would 
be implemented like this: 
</p>

<pre>using System; 
using CookComputing.XmlRpc; 

struct SumAndDiffValue 
{ 
  public int sum; 
  public int difference; 
}
 
class SumAndDiffService : XmlRpcService
{ 
  [XmlRpcMethod(&quot;sample.sumAndDifference&quot;)] 
  public SumAndDiffValue SumAndDifference(int x, int y) 
  { 
    SumAndDiffValue ret; 
    ret.sum = x + y; 
    ret.difference = x – y; 
    return ret; 
  } 
} </pre>

<p>
If this code is saved to a file called sumanddiff.cs the Service can be built 
using the following command line: 
</p>

<pre>csc /r:system.web.dll /r:CookComputing.XmlRpcV2.dll /target:library sumanddiff.cs  </pre>

<p>
This will build a dll assembly called sumanddiff.dll. 
</p>

<h4>Configuring the Service</h4>

<p>
The Service has to be placed in a virtual directory, say xmlrpc in this case, 
which has a sub-directory called bin. A configuraton file called web.config 
is created in the virtual root directory containing the following information 
to specify that the Service should be invoked when a HTTP request arrives for 
this URL: </p>
<pre>&lt;configuration&gt;
  &lt;system.web&gt; 
    &lt;httpHandlers&gt;
      &lt;add verb=&quot;*&quot; path=&quot;SumAndDiff.rem&quot; 
         type=&quot;SumAndDiffService, sumanddiff&quot; /&gt;
    &lt;/httpHandlers&gt;
  &lt;/system.web&gt;
&lt;/configuration&gt;</pre>

<p>
The config file specifies that if the final segment of the URL is SumAndDiff.rem 
the handler in the class SumAndDifference will be invoked. Note that the assembly 
qualified name of the class is used so that ASP.NET knows which assembly to 
load the class from. 
</p>

<p>
The HTTP verb is specified by a wildcard. The implementation in XmlRpcService 
handles both POST for XML-RPC method calls and GET to return an automatically 
generated documentation on the Service. XmlRpcService will reject any other 
requests with the appropriate HTTP response code. 
</p>

<p>
The extension used for the URL is “.rem”. This is for convenience because ASP.NET 
is configured by default to handle a number of extensions including .rem, .aspx, 
and .asmx. Other extensions could be used, for example .xmlrpc would be an obvious 
choice, but this involves changing the configuration of the virtual directory 
via the IIS management snap-in. 
</p>

<p>
Once the service is configured a quick check can be made by pointing your browser 
at the URL and verifying that the automatically generated help page is displayed.
</p>

<h3><a id="3.3"></a>3.3 How do I implement an XML-RPC server using .NET Remoting?</h3>

<p>XML-RPC.NET includes a Remoting formatter sink provider, the class 
XmlRpcServerFormatterSinkProvider. When configured this enables the Remoting 
infrastructure to handle incoming XML-RPC requests as well as SOAP requests. 
</p>

<pre>using System;
using System.Runtime.Remoting;
using CookComputing.XmlRpc;

public struct SumAndDiffValue 
{ 
  public int sum; 
  public int difference; 
}

public class SumAndDiff : MarshalByRefObject 
{ 
  [XmlRpcMethod("sample.sumAndDifference")] 
  public SumAndDiffValue SumAndDifference(int x, int y) 
  { 
    SumAndDiffValue ret; 
    ret.sum = x + y; 
    ret.difference = x - y; 
    return ret; 
  } 
} 
</pre>

<p>
Note that instead of deriving the service class from XmlRpcService, it is now 
derived from MarshalRefByObject.<br/>
</p>

<pre>class XmlRpcServer

{
  static void Main(string[] args) 
  { 
    // for CookComputing.XmlRpcV2
    RemotingConfiguration.Configure("SumAndDiff.exe.config", false); 
    // for CookComputing.XmlRpc
    //RemotingConfiguration.Configure("SumAndDiff.exe.config"); 
    RemotingConfiguration.RegisterWellKnownServiceType(
      typeof(SumAndDiff), 
      "SumAndDiff.rem",
      WellKnownObjectMode.Singleton); 
    Console.WriteLine("Press to shutdown"); 
    Console.ReadLine(); 
  } 
}</pre>

<p>
A config file is needed to specify that the Remoting infrastructure uses the 
XML-RPC.NET formatter:
</p>

<pre>&lt;configuration&gt; 
  &lt;system.runtime.remoting&gt;
    &lt;application&gt;      
      &lt;channels&gt;         
        &lt;channel ref=&quot;http&quot; port=&quot;5678&quot;&gt;
          &lt;serverProviders&gt;<br/>            &lt;formatter<br/>  type=&quot;CookComputing.XmlRpc.XmlRpcServerFormatterSinkProvider, CookComputing.XmlRpcV2&quot; 
            /&gt;            
            &lt;formatter ref=&quot;soap&quot; /&gt;       
          &lt;/serverProviders&gt;
        &lt;/channel&gt;
      &lt;/channels&gt;
    &lt;/application&gt;   
  &lt;/system.runtime.remoting&gt; 
&lt;/configuration&gt;</pre>

<p>
Note that the default SOAP formatter is the second formatter so that if the 
XML-RPC formatter does not recognize the request it can pass the request onto 
the next formatter. The file also specifies that the server listens on port 
5678.
</p>

<p>
To limit access to the service to clients on the local machine only, specify 
localhost as the bindTo address in the config file:
</p>

<pre>&lt;channel ref=&quot;http&quot; port=&quot;5678&quot; bindTo=&quot;127.0.0.1&quot;&gt;
</pre>

<p>
Finally, in some scenarios other code in the application may be required to 
interact with the service object, for example to subscribe to events on the
service object and receive notifications when a request is processed. The 
code above makes this difficult because the application is not explicitly 
instantiating the service object. Vitor Silva has suggested this alternative:
</p>

<pre>
    RemotingConfiguration.Configure("SumAndDiff.exe.config"); 
    MyRemObj myremobj = new MyRemObj();
    RemotingServices.Marshal(myremobj, "MyRemObjUri", typeof(myremobj));
</pre> 




<h3><a id="3.4"></a>3.4 How do I implement an XML-RPC server in IIS using .NET Remoting</h3>

<p>
A virtual directory is created and the assemblies placed in a sub-directory 
called <b>bin</b>. The config file is called <b>web.config</b> in this case 
and specifies two aspects of the server: the service element specifies the server 
class and its URL, and the channels element specifies that two formatters are 
supported, the default SOAP formatter and the XML-RPC formatter.
</p>

<pre>&lt;configuration&gt; 
  &lt;system.runtime.remoting&gt; 
    &lt;application&gt; 
      &lt;service&gt; 
        &lt;wellknown mode=&quot;Singleton&quot;    
                   type=&quot;SumAndDifference, sumanddiff&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       &nbsp;     objectUri=&quot;SumAndDiff.rem&quot; /&gt; 
      &lt;/service&gt; 
      &lt;channels&gt; 
        &lt;channel ref=&quot;http&quot;&gt;    
          &lt;serverProviders&gt;    
            &lt;formatter    
type=&quot;CookComputing.XmlRpc.XmlRpcServerFormatterSinkProvider, CookComputing.XmlRpcV2&quot; /&gt; 
            &lt;formatter ref=&quot;soap&quot; /&gt; 
          &lt;/serverProviders&gt;    
        &lt;/channel&gt;  
      &lt;/channels&gt; 
    &lt;/application&gt; 
  &lt;/system.runtime.remoting&gt; 
&lt;/configuration&gt; </pre>

<p>
Obviously the URL used by the client should be changed to connect to IIS, for 
example:
</p>

<pre>SumAndDifference svr = (SumAndDifference)Activator.GetObject(
  typeof(SumAndDifference), <br/>  &quot;http://localhost/xmlrpc/SumAndDiff.rem&quot;);</pre>


<h3><a id="3.5"></a>3.5 Do XML-RPC.NET servers implement the XML-RPC Introspection API?</h3>

<p>
The base class for implementing all types of XML-RPC server is XmlRpcServerProtocol. 
This implements the Introspection API and so all XML-RPC.NET endpoints automatically 
expose this API. 
</p>


<h3><a id="3.6"></a>3.6 What is Automatic Documentation?</h3>

<p>
XmlRpcHttpServerProtocol is the base class for implementing an XML-RPC endpoint 
in an HTTP server. This class handles GET requests by dynamically generating 
a help page for the endpoint using reflection.
</p>

<p>
The following attributes each take an optional named parameter called <b>Description</b> 
  in their constructor:
</p>

<p>- XmlRpcService<br/>
  - XmlRpcMethod<br/>
  - XmlRpcParameter<br/>
  - XmlRpcReturnValue
</p>

<p>
The automatic documentation is generated using the method names of the class, 
the parameter types, and the values of the <b>Description</b> property of all 
attributes which hae been defined.
</p>


<h3><a id="3.7"></a>3.7 How do I support authentication in my XML-RPC service?</h3>

<p>
Authentication is not provided by standalone .NET Remoting and if required 
must be implemented by the developer. On the other hand IIS does support authentication 
and so the two IIS-based methods on implementing servers can be used where authentication 
is required. Configuration is exactly the same as for normal web pages and 
is described in the IIS online documentation.
</p>

<h3><a id="3.8"></a>3.8 Can I implement a server which supports both XML-RPC and SOAP?</h3>

<p>
Yes, if using .NET Remoting and the soap formatter is configured as well as 
the XML-RPC formatter, the server will handle both XML-RPC and SOAP requests.
</p>

<pre>&lt;configuration&gt; 
    &lt;system.runtime.remoting&gt;    
        &lt;application&gt; 
            &lt;channels&gt; 
                &lt;channel ref=&quot;http&quot; port=&quot;5678&quot;&gt; 
                    &lt;serverProviders&gt;
                       &lt;formatter
type=&quot;CookComputing.XmlRpc.XmlRpcServerFormatterSinkProvider, CookComputing.XmlRpc&quot;/&gt;            
                        &lt;formatter ref=&quot;soap&quot; /&gt;       
                    &lt;/serverProviders&gt; 
                &lt;/channel&gt; 
            &lt;/channels&gt; 
        &lt;/application&gt; 
    &lt;/system.runtime.remoting&gt; 
&lt;/configuration&gt;</pre>

<h3><a id="3.9"></a>3.9 Can I run XML-RPC.NET services with other web servers?</h3>

<p>
Yes - as long as the web server supports ASP.NET. This is not as implausible 
as it might sound because it is fairly easy to host ASP.NET using the .NET implementation 
of System.Web.Hosting. An example of this is the <a href="http://www.asp.net/Projects/Cassini/Download/">Cassini 
Web Serve</a>r implemented by the ASP.NET team.
</p>

<p>
One point worth mentioning when running Cassini is that assemblies by default 
must be placed in a directory called <b>bin</b> under the virtual root. For 
example, if the URL of the service is <b>http://localhost/xmlrpc/math.rem</b> 
assemblies are loaded from virtual<b> /bin</b> and not virtual <b>/xmlrpc/bin</b>. 
In this example the config file is placed in the virtual <b>/xmlrpc</b> directory 
and would look like this:
</p>

<pre>&lt;configuration&gt;
  &lt;system.web&gt;
    &lt;httpHandlers&gt;
      &lt;add verb=&quot;*&quot; path=&quot;math.rem&quot; type=&quot;MathService, MathService&quot; /&gt;
    &lt;/httpHandlers&gt; 
  &lt;/system.web&gt;
&lt;/configuration&gt;
</pre>


<h3><a id="3.10"></a>3.10 Can I implement Services in other languages?</h3>

<p>
Services can be implemented in any CLS compliant language as the samples in 
this section illustrate.
</p>

<h4>VB.NET</h4>

<pre>Imports CookComputing.XmlRpc

Public Structure SumAndDiffValue
  Public sum As Integer
  Public difference As Integer
End Structure


Public Class SumAndDiffService
  Inherits XmlRpcService


 &lt;XmlRpcMethod(&quot;sample.sumAndDifference&quot;)&gt; _
 Public Function SumAndDifference(ByVal x As Integer, _
                                  ByVal y As Integer) _
                                  As SumAndDiffValue
   Dim ret As SumAndDiffValue
   ret.difference = x - y
   ret.sum = x + y
   Return ret
 End Function

End Class
</pre>


<h3><a id="3.11"></a>3.11 Can I implement a service in an ASHX file?</h3>

<p>
ASHX files provide a very simple way to deploy XML-RPC services without building assemblies 
and configuring a web.config file. Create a file like this with a .ashx extension and place 
it in a web directory which has a sub-directory called bin containing CookComputing.XmlRpcV2 assembly: 
</p>
<pre>&lt;%@ WebHandler Language= "VB" Class="Test" %&gt;
&lt;%@ Assembly Name="CookComputing.XmlRpcV2" %&gt;

Imports CookComputing.XmlRpc

&lt;XmlRpcService&gt; _
Public Class Test Inherits XmlRpcService
    &lt;XmlRpcMethod&gt; _
    Public Function Foo(ByVal x as Integer) As Integer
        Return x * x
    End Function
End Class
</pre>

<p>
ASHX web handlers can be written in C# a similar way.
</p>


<h3><a id="3.12"></a>3.12 How do I implement an XML-RPC server using HttpListener?</h3>

<p>
The .Net System.Net.HttpListener class can be used as the basis for 
an XML-RPC server implemented using XML-RPC.NET.

First, the service functionality is implemented in a class deriving from the 
CookComputing.XmlRpc.XmlRpcListenerService class:
</p>

<pre>
public class StateNameService : XmlRpcListenerService
{
  [XmlRpcMethod("examples.getStateName")]
  public string GetStateName(int stateNumber)
  {
    if (stateNumber &lt; 1 || stateNumber &gt; m_stateNames.Length)
      throw new XmlRpcFaultException(1, "Invalid state number");
    return m_stateNames[stateNumber - 1];
  }

  string[] m_stateNames
    = { "Alabama", "Alaska", "Arizona", "Arkansas",
        "California", "Colorado", "Connecticut", "Delaware", "Florida",
        "Georgia", "Hawaii", "Idaho", "Illinois", "Indiana", "Iowa", 
        "Kansas", "Kentucky", "Lousiana", "Maine", "Maryland", "Massachusetts",
        "Michigan", "Minnesota", "Mississipi", "Missouri", "Montana",
        "Nebraska", "Nevada", "New Hampshire", "New Jersey", "New Mexico", 
        "New York", "North Carolina", "North Dakota", "Ohio", "Oklahoma",
        "Oregon", "Pennsylviania", "Rhose Island", "South Carolina", 
        "South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", 
        "Washington", "West Virginia", "Wisconsin", "Wyoming" };
}
</pre>

<p>
Acquiring the request synchronously via the HttpListener GetContext method, 
the top level code could look like this: 
</p>

<pre>
using System;
using System.IO;
using System.Net;
using CookComputing.XmlRpc;

class _
{
  public static void Main(string[] prefixes)
  {
    HttpListener listener = new HttpListener();
    listener.Prefixes.Add("http://127.0.0.1:11000/");
    listener.Start();
    while (true)
    {
      HttpListenerContext context = listener.GetContext();
      XmlRpcListenerService svc = new StateNameService();
      svc.ProcessRequest(context);
    }
  }
}
</pre>

<p>
Note that the HttpListener class can also be used asynchronously.
</p>


<h3><a id="3.13"></a>3.13 Can I customise the XML returned by a service?</h3>
<p>The format of the XML returned by a service can be customised by setting 
the following atttributes on the service class:
</p>
<ol>
<li>
Indentation - uses to define the number of spaces worth of indentation for
 response elements; the default is 2.
</li>
<li>
UseIndentation - if set to true responses are formatted across multiple lines;
if set to false a response is formatted as a single line; the default is true.
</li>
<li>
UseIntTag - if set to true integer values in responses are formatted as
&lt;int&gt; if set to false they are formatted as &lt;i4&gt;; 
the default is false.
</li>
<li>
UseStringTag - if set to true string values in responses are formatted as
&lt;string&gt;; if set to false they are formatted as simply the text contained
by the &lt;value&gt; element; the default is true.
</li>
<li>
XmlEncoding - this is used to specify the text encoding of responses. By default
UTF-8 is used.
</li>
</ol>
<p>
For example:
</p>

<pre>using System; 
using CookComputing.XmlRpc; 

struct SumAndDiffValue 
{ 
  public int sum; 
  public int difference; 
}

[XmlRpcService(XmlEncoding="ISO-8859-1", Indentation=1, 
    UseStringTag=false, UseIntTag=true, UseIndentation=true)] 
class SumAndDiffService : XmlRpcService
{ 
  [XmlRpcMethod(&quot;sample.sumAndDifference&quot;)] 
  public SumAndDiffValue SumAndDifference(int x, int y) 
  { 
    SumAndDiffValue ret; 
    ret.sum = x + y; 
    ret.difference = x – y; 
    return ret; 
  } 
} </pre>

<h2>4. Error Handling</h2>


<h3><a id="4.1"></a>4.1 How are XML-RPC Fault Responses represented?</h3>

<p>
An XML-RPC Fault Response contains a struct with two members: a fault code 
and a fault description:
</p>

<pre>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;methodResponse&gt;
  &lt;fault&gt;
    &lt;value&gt;
      &lt;struct&gt;
        &lt;member&gt;
          &lt;name&gt;faultCode&lt;/name&gt;
          &lt;value&gt;&lt;int&gt;4&lt;/int&gt;&lt;/value&gt;
        &lt;/member&gt;
        &lt;member&gt;
          &lt;name&gt;faultString&lt;/name&gt;
          &lt;value&gt;&lt;string&gt;Too many parameters.&lt;/string&gt;&lt;/value&gt;
        &lt;/member&gt;
      &lt;/struct&gt;
    &lt;/value&gt;
  &lt;/fault&gt;
&lt;/methodResponse&gt;</pre>

<p>
XML-RPC.NET maps Fault Responses onto .NET exceptions, more specifically a 
type called XmlRpcFaultException. This is derived from System.ApplicationException 
and contains two properties: int FaultCode and string FaultDescription. Server 
application code simply throws an instance of this exception where required 
and XML-RPC.NET catches it and returns it as a Fault Response. For example:
</p>

<pre>throw new XmlRpcFaultException(100, &quot;Invalid argument&quot;); </pre>

<p>
On the client side XML-RPC.NET receives the Fault Response, extracts the code 
and description, and throws a corresponding instance of XmlRpcFaultException. 
Client code can catch this exception using a try-catch block. For example:
</p>

<pre>SumAndDiffProxy sdprxy = new SumAndDiffProxy();
try
{
  SumAndDiffValue ret = sdprxy-&gt;SumAndDifference(2, 3);
}
catch (XmlRpcFaultException fex)
{
  Console.WriteLine(&quot;Fault Response: {0} {1}&quot;, 
    fex.FaultCode, fex.FaultString);
}</pre>


<h3><a id="4.2"></a>4.2 How are other types of error returned?</h3>

<p>
Error conditions can occur at other stages of an XML-RPC call. These fall into 
two categories, the first being networking errors, for example the client failing 
to connect to the server because the URL is invalid or the server is down. The 
second category is where the XML-RPC request reaches the server but cannot be 
processed for some reason, for example because it is not a valid XML-RPC request 
or the server application code crashes while processing the request. 
</p>

<p>
Unfortunately XML-RPC does not provide a way of differentiating between an 
application level error and a protocol level or internal error, for example 
if the request is not a valid XML-RPC request. One approach is to define a well-known 
set of error codes which will be used by all XML-RPC implementations but this 
suffers from the drawback that this set of error codes cannot be guaranteed 
to never conflict with the error codes that application code may need to return. 
Application code can certainly choose its own error codes but may also need 
to return error codes from third party code, for example from a database. 
</p>

<p>
Currently XML-RPC.NET returns a fault code of zero when a protocol or internal 
error occurs, leaving all other error codes available for application level 
error reporting.
</p>

<h3><a id="4.3"></a>4.3 What happens if the return value of a proxy method is incorrect?</h3>

<p>
If a proxy method is defined to return the wrong data type an instance of XmlRpcTypeMismatchException 
is thrown when the response is parsed. For example, if the sample.SumAndDifference 
method was incorrectly defined to return a string:
</p>

<pre>[XmlRpcUrl("http://www.cookcomputing.com/sumAndDiff.rem")] 
public interface ISumAndDiff : IXmlRpcProxy
{ 
  [XmlRpcMethod] 
  string SumAndDifference(int x, int y);
} 
</pre>

<p>
an instance of XmlRpcTypeMismatchException would be thrown, containing the 
message &quot;param element contains unexpected struct element&quot;. This is   <!-- CHECK THIS --> 
because the XML-RPC response contains a struct but the deserializer is expecting 
a string (it knows this from reflecting on the return value of the proxy method).
</p>


<h2>5. Debugging</h2>


<h3><a id="5.1"></a>5.1 How do I monitor XML-RPC calls across the network?</h3>

<p>
A very useful tool for monitoring the HTTP requests and responses associated 
with an XML-RPC call is <b><a href="http://www.pocketsoap.com/tcptrace/">tcptrace</a>.</b> 
This enables you to view the headers and content of HTTP requests. Configure 
it to use an unused port on your machine and set the destination server and 
destination port to those of the XML-RPC endpoint. Point your client at the 
local port you have chosen and all XML-RPC requests will pass through tcptrace, 
which will display in particular the request and response XML documents.
</p>

<p>
Perhaps even more useful is the HTTP debugging proxy called 
<a href="http://www.fiddlertool.com/fiddler/">Fiddler</a>. This allows you
to look at requests and responses as text, hex, or xml.
</p>

<h4>Logging</h4>

<p>
The simplest way to log the content of XML-RPC requests and responses is to
attach an instance XmlRpcDebugLogger to your proxy, for example:
</p>

<pre>IStateName proxy = XmlRpcProxyGen.Create&lt;IStateName&gt;();
proxy.AttachLogger(new XmlRpcDebugLogger());
</pre>

<p>
This will result in the XML of the request and response for each call being 
written to the currently configured Debug listeners. When using Visual Studio 
the default listener writes to the Output window. 
</p>

<p>
Proxies expose two events - RequestEvent and ResponseEvent - which 
provide access to the streams containing the request and response XML for 
each XML-RPC call. The delegates used to subscribe to these events are:</p>

<pre>public delegate void XmlRpcRequestEventHandler(
  object sender, 
  XmlRpcRequestEventArgs args);

public delegate void XmlRpcResponseEventHandler(
  object sender, 
  XmlRpcResponseEventArgs args);
</pre>

<p>
XmlRpcRequestEventArgs has properties which provide information for logging
the request: ProxyID, a Guid uniquely identify the proxy instance; RequestNum, 
an ascending number uniquely identifying the request within the current 
AppDomain; and RequestStream, a stream containing the XML request which will 
be sent to the server. 
</p>

<p>
XmlRpcResponseEventArgs has similar properties, the difference being that it
has a ResponseStream property instead of RequestStream. 
</p>

<p>
The library contains a helper abstract class - XmlRpcLogger - which simplifies attaching
logging code to a proxy. The classes XmlRpcDebugger and Tracer are examples of how 
to derive from XmlRpcLogger (Tracer is similer to XmlRpcDebugger but it writes to
the Trace listener(s) instead of the Debug listener(s)).
</p>

<p>
The XML-RPC.NET assembly also contains the class
RequestResponseLogger which can be used to dump the contents of request and 
responses to individual files. This is useful when it is necessary to examine
the exact content that it is being sent to and returned from the server. 
RequestResponseLogger has a Directory property to specify where the files 
should be written to, the default being the current directory. The filenames 
for requests and response pairs look like this:
</p>

<p>
632880530803281250-0002-request-351884cb-cbde-417e-906e-b1424f617d89.xml<br />
632880530803281250-0002-response-351884cb-cbde-417e-906e-b1424f617d89.xml
</p>

<p>
The first number is the number obtained from DateTime.Now.Ticks, the second 
number is the id of the request, and the guid is the id of the proxy used to
make the call. 
</p>

<p>
RequestResponseLogger is used in the same way as the Tracer class (see 
LoggingSample in the distribution):
</p>

<pre>IStateName proxy = XmlRpcProxyGen.Create&lt;IStateName&gt;();
proxy.AttachLogger(new RequestResponseLogger());
string ret = proxy.GetStateName(45);
</pre>

<h3><a id="5.2"></a>5.2 How do I debug an XML-RPC.NET service?</h3>

<p>
XML-RPC.NET services under IIS run within the aspnet_wp.exe process and so 
must be debugged by attaching a debugger to this process.
</p>

<h4>Using the SDK Debugger</h4>

<p>
To attach to aspnet_wp.exe from the .NET SDK debugger - <b>dbgclr.exe</b> - 
perform these steps:</p>

<ol>
  <li>Call the service to ensure aspnet_wp.exe is running and the service is loaded.</li>
  <li>Launch the debugger.</li>
  <li> Use the <b>File...Open File</b> menu item to open the source file for the 
    page you want to debug.</li>
  <li>From the <b>Tools</b> menu, choose <b>Debug Processes</b>. Check the <b>Show</b> 
    system processes checkbox, if it is not checked (this may not be necessary, 
    depending on the account aspnet_wp.exe is running under).</li>
  <li>Find the aspnet_wp.exe process and double-click it to attach to it.</li>
  <li>Close the <b>Processes</b> dialog. </li>
</ol>

<p>
To debug the service, place breakpoints in the source file and call the service.
</p>

<h4>Using the Visual Studio .NET Debugger</h4>

<p>
To attach to aspnet_wp.exe from Visual Studo .NET, perform the following steps:
</p>

<ol>
  <li>Call the service to ensure aspnet_wp.exe is running and the service is loaded.</li>
  <li>Open the project which implements the service you want to debug.</li>
  <li>From the <b>Debug</b> menu, choose <b>Processes</b>.</li>
  <li>Find the aspnet_wp.exe process and double-click it</li>
  <li>Check <b>Common Language Runtime</b> on the <b>Attach to Process</b> dialog 
    which then appears and click <b>OK</b>. (It is ok to leave <b>Native</b> checked.)</li>
  <li>Close the <b>Processes</b> dialog.</li>
</ol>

<p>
To debug the service, place breakpoints in the source file and call the service.
</p>

<p><b>Using Cassini</b></p>

<p>
The easiest method of debugging a service is to use the <a href="http://www.asp.net/Projects/Cassini/Download/">Cassini</a> 
web server. In either the SDK debugger or Visual Studio set the program to be 
run as the Cassini executable and set the arguments as required by Cassini, 
  <b>&lt;physical-path&gt; &lt;port&gt; &lt;virtual-path&gt;</b>, 
  for example:
</p>

<p>
<b>c:\cassini\wwwroot &nbsp;&nbsp;82&nbsp;&nbsp;/</b>
</p>

<p>
Set breakpoints and then select <b>Debug..Start</b> or hit <b>F5</b>. The advantage 
of using Cassini is that you don't have to re-attach the debugger each time 
you rebuild the service.
</p>


<h2>6. Miscellaneous</h2>


<h3><a id="6.1"></a>6.1 Which XML Encodings are Supported? </h3>

<p>
XML-RPC.NET uses compliant XML parsers and writers. It outputs XML in the UTF-8 
encoding by default and accepts various encodings when reading XML, for example 
UTF-8, UTF-16, ISO-8859-1, etc.
</p>

<p>
String handling in XML-RPC is problematic because the XML-RPC standard is inconsistent 
in this area. XML-RPC.NET handles the issue by specifying that the string value 
element can contain any Unicode character which can be contained in XML text 
content.
</p>

<p>When sending a request it is possible to specify the encoding by setting the 
XmlEncoding property of the proxy class. For example:</p>

<pre>SumAndDiffProxy proxy = new SumAndDiffProxy();
proxy.XmlEncoding = new System.Text.ASCIIEncoding();
SumAndDiffValue ret = proxy.SumAndDifference(2, 3);</pre>

<p>
Refer to the .NET Framework documentation for the encodings that are supported. 
</p>


<h3><a id="6.2"></a>6.2 Which Code Access Security Permissions are Required?</h3>

<p>
XML-RPC.NET needs a minimal set of Code Access Security (CAS) permissions, 
in particular networking permission to connect to a server. In the case of downloadable 
smart clients this could be restricted to connecting to the server from which 
the client was downloaded. 
</p>


<h3><a id="6.3"></a>6.3 Why is the key file not included in the distribution?</h3>

<p>
Building XML-RPC.NET from the distribution will fail because of a missing file 
called <b>CookComputing.key</b>. This contains the public/private key pair used 
to sign the CookComputing.XmlRpcV2.dll assembly with a strong name. The file is 
not distributed because this would enable anyone else to build a malicious version 
of the assembly and pass it off as originating from Cook Computing. 
</p>

<p>
To generate your own key file using the sn.exe tool as follows:
</p>

<pre>sn -k mykeyfile.snk</pre>

<p>
and modify the relevant line in assemblyinfo.cs:
</p>

<pre>[assembly: AssemblyKeyFile("mykeyfile.snk")]
</pre>

<p>
Alternatively, comment out this line if you do not need to sign your assembly 
with a strong name.<br/>
</p>


<h3><a id="6.4"></a>6.4 How do I verify an XML-RPC.NET assembly is genuine?</h3>

<p>
Use the sn.exe tool to extract the public key token from the assembly:
</p>

<pre>sn -T cookcomputing.xmlrpcV2.dll</pre>

<p>
The token should be the same as this if the assembly was built using the Cook 
Computing key file:
</p>

<pre>a7d6e17aa302004d
</pre>


<h3><a id="6.5"></a>6.5 Can I define an interface from which both the proxy and server classes are derived?</h3>

<p>
Yes, although you will need to derive a class from the interface which also
derives from IXmlRpcProxy for use with XmlRpcProxyGen, for example:
</p>

<pre>public interface ISumAndDiff
{ 
  [XmlRpcMethod] 
  SumAndDiffValue SumAndDifference(int x, int y);
} 

public interface ISumAndDiffClient : ISumAndDiff, IXmlRpcProxy
{ 
} 
</pre>




<h3><a id="6.6"></a>6.6 How do I implement a client when code generation is not allowed?</h3>

<p>
Sometimes client code will need to run without the security permissions for  
code generation which are necessary to create proxy classes using 
XmlRpcProxyGen.Create, for example when running in the untrusted internet security 
zone. In this scenario it is necessary to implement proxies manually.
</p>

<pre>using System.Reflection;
using CookComputing.XmlRpc;

struct SumAndDiffValue 
{
  public int sum; 
  public int difference; 
}

[XmlRpcUrl("http://www.cookcomputing.com/sumAndDiff.rem")] 
class SumAndDiffProxy : XmlRpcClientProtocol 
{ 
  [XmlRpcMethod] 
  SumAndDiffValue SumAndDifference(int x, int y) 
  { 
    return (SumAndDiffValue)Invoke(MethodBase.GetCurrentMethod(), 
                                   new Object[]{ x, y }); 
  } 
} 
</pre>

<p>
The SumAndDiffValue is defined to represent the result of the sample.sumAndDifference 
XML-RPC call. Each member of the struct represents a member of the XML-RPC struct 
returned by the call. Note that members must be defined as public.
</p>

<p>
The XmlRpcUrl attribute is applied to the proxy class to specify the URL of 
  the server endpoint.
</p>

<p>
The class being defined derives from XmlRpcClientProtocol to inherit the required 
proxy functionality.
</p>

<p>Each method representing an XML-RPC method is marked with the XmlRpcMethod 
attribute.
</p>

<p>
The SumAndDifference method is defined to represent the XML-RPC call. The member 
function Invoke (inherited from XmlRpcClientProtocol) is called, passing the 
current function and the parameters to the call in an array of type 
Object. The value returned from Invoke is cast to the required return type for 
the function and returned.
</p>

<p>
Note that in cases where MethodBase.GetCurrentMethod() is not available, for
example with the Compact Framework, the name of the currentmethod should be 
passed instead (<b>NOT</b> the name of the XML-RPC method which might be
different).
</p>

<p>
Use the proxy class like this:
</p>

<pre>SumAndDiffProxy proxy = new SumAndDiffProxy();
SumAndDiffValue ret = proxy.SumAndDifference(2, 3);</pre>

<p>
The proxy class can also be manually coded in VB.NET:
</p>


<pre>Imports CookComputing.XmlRpc
Module SumAndDiffSample
  Public Structure SumAndDiffValue
    Public sum As Integer
    Public difference As Integer
  End Structure<br/>
  &lt;XmlRpcUrl(&quot;http://www.cookcomputing.com/sumAndDiff.rem&quot;)&gt; _
  Public Class SumAndDiffProxy
    Inherits XmlRpcClientProtocol<br/>    &lt;XmlRpcMethod(&quot;sample.sumAndDifference&quot;)&gt; _
    Public Function SumAndDifference(ByVal x As Integer, _
                                     ByVal y As Integer) _
                                     As SumAndDiffValue
      Return Invoke(MethodBase.GetCurrentMethod(), New Object() { x , y })
    End Function
  End Class

  Sub Main()
    Dim proxy As New SumAndDiffProxy()
    Dim strct As New SumAndDiffValue()
    proxy.SumAndDifference(2, 3)
  End Sub

End Module
</pre>



<h3><a id="6.7"></a>6.7 Why does my client throw exception &quot;Invoke on 
non-existent proxy method&quot;?</h3>

<p>
This problem can occur when the first parameter to Invoke is the current method
name and not the return value from MethodBase.CurrentMethod().
When manually implementing a proxy method there are two method names involved: 
the name of the proxy method and the name of the XML-RPC method. These names 
are not necessarily the same, and if the first parameter of Invoke is the 
XML-RPC method name, and not the proxy method name, an exception is thrown 
with the message: &quot;Invoke on non-existent proxy method&quot;. This 
problem can be avoided by following these rules when using the method name 
with Invoke:
</p>

<ol>
<li>
The call to <b>Invoke</b> always passes the name of the <b>proxy method</b>. 
</li>
<li>If the the name of XML-RPC method is not the same as the name of the proxy 
method, the <b>XML-RPC method</b> name is specified by passing it to the 
<b>XmlRpcMethod 
attribute</b>.
</li>
</ol>

<p>
The reason for this is that there are two stages of serialization when making 
an XML-RPC call. The first is performed by the implementation of the proxy method, 
converting the call into a method name and an array of type Object which contains 
the parameters.This representation of the call is then passed to the XmlRpcClientProtocol 
class using the Invoke method. The second stage is when the method name and 
parameter array are converted into the XML request. 
</p>

<p>
For the second stage to work effectively it needs to how the parameters should 
be mapped onto the params element of the XML request and what method name should 
be specified in the methodCall element. The first point is handled by using 
reflection on the proxy method, hence the need for the proxy method name, and 
the second point is handled by using the name specified in the XmlRpcMethod 
attribute (or the proxy method name if a name is not specified in the attribute).
</p>

<h3><a id="6.8"></a>6.8 Does XmlRpcClientProtocol.Invoke use params for the array of parameters?</h3>

<p>
When calling XmlRpcClientProtocol.Invoke, the parameter which passes the array 
of method parameters is defined with the params keyword. This means that instead 
of calling Invoke with an explcitly declared array of type object[], we can 
pass the method parameters as individual parameters to Invoke. For example, 
this proxy method:
</p>

<pre>[XmlRpcMethod] SumAndDiffValue SumAndDifference(int x, int y)
{
  return (SumAndDiffValue)Invoke("SumAndDifference", new Object[]{ x, y }); 
} </pre>

<p>
can be coded as:
</p>

<pre>[XmlRpcMethod] SumAndDiffValue SumAndDifference(int x, int y)
{
  return (SumAndDiffValue)Invoke("SumAndDifference", x, y); 
} 
</pre>


<h3><a id="6.9"></a>6.9 How do I manually implement asynchronous requests?</h3>
<p>
For cases where a manually implemented proxy is required, such as with Windows Phone, it is possible to make 
asynchronous calls via the BeginInvoke and EndInvoke methods of XmlRpcClientProtocol. 
</p>

<p>
In both cases two new methods must be implemented in the proxy class for each 
XML-RPC method. For example:
</p>

<pre>[XmlRpcUrl("http://www.cookcomputing.com/sumAndDiff.rem")]
class SumAndDiffProxy : XmlRpcClientProtocol 
{
  [XmlRpcMethod("sample.sumAndDifference")] 
  SumAndDiffValue SumAndDifference(int x, int y) 
  { 
    return (SumAndDiffValue)Invoke("SumAndDifference", new Object[]{ x, y }); 
  } 
   
  public IAsyncResult BeginSumAndDifference(int x, int y, AsyncCallback callback,    
                                            object asyncState) 
  { 
    return BeginInvoke("SumAndDifference", new object[]{x, y}, callback, asyncState);    
  } 

  public Result EndSumAndDifference(IAsyncResult asr) 
  { 
    return EndInvoke&lt;Result&gt;(asr); 
  } 
} </pre>


<h3><a id="6.10"></a>6.10 Does XML-RPC.NET work with Mono?</h3>

<p>
Although XML-RPC.NET is not developed and tested in a Mono environment,
there should be no problem running with Mono, either on Windows or Linux.
</p>


<h3><a id="6.11"></a>6.11 Does XML-RPC.NET work with .Net Compact Framework?</h3>

<p>
The XML-RPC.NET distribution contains an assembly which provides support for
the .NET Compact Framework: <b>CookComputing.XmlRpc.CF.dll</b>. Note that
this is an experimental version and is mostly untested. Also, because the 
Compact Framework does not support reflection it is necessary to implement 
XML-RPC.NET proxies manully.
</p>


<h3><a id="6.12"></a>6.12 How does the XML-RPC.NET license affect my product?</h3>

<p>
XML-RPC.NET is released under the terms of the <a 
href="http://www.opensource.org/licenses/mit-license.html">MIT X11</a> license:
</p>

<blockquote style="font-style: italic;font-weight:bold">
<p>
The MIT License
</p>

<p>
Copyright (c) 2006 Charles Cook
</p>

<p>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
</p>

<p>
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
</p>

<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p>
</blockquote>

<p> 
This license is not "viral" and so does not affect the licensing of any product 
which uses XML-RPC.NET. The only requirement is that any copyright notices 
contain a copyright notice for XML-RPC.NET, for example:
</p>

<blockquote  style="font-style: italic;font-weight:bold">
<p> 
"XML-RPC.NET Copyright (c) 
2006 Charles Cook".
</p>
</blockquote>


<h3><a id="6.13"></a>6.13 How do I build XML-RPC.NET?</h3>


<p>
As of version 2.0.0 XML-RPC.NET is built using 
<a href="http://msdn2.microsoft.com/en-us/library/wea2sca5.aspx">MSBuild</a>. 
This allows the same project files to be used either from the command line 
using MSBuild or from within Visual Studio 2005 (note that Visual Studio 2003 
cannot be used).
</p>

<p>
Additional tasks and targets are 
provided by the <a href="http://msbuildtasks.tigris.org/">MSBuild Community Tasks Project</a>. 
For running unit tests in the build it is necessary to install version 2.2.7 of 
<a href="http://www.nunit.org/">NUnit</a>.
</p>

<p>
To build CookComputing.XmlRpc.dll - the assembly built using the .NET 1.0 
compiler it is necessary to build from the command line:
</p>


<pre>msbuild xml-rpc.net.proj /t:BuildXmlRpc1_0
</pre>


<h2>7. Resources</h2>

<h3><a id="7.1"></a>7.1 XML-RPC Specification</h3>

<p>
Dave Winer's XML-RPC specification is available <a href="http://www.xmlrpc.com/spec">here</a>. 
</p>

<h3><a id="7.2"></a>7.2 Books and Tutorials</h3>

<p>
The following book is worth reading if you are working with XML-RPC. As well 
as clearing up some of the issues in the spec it includes chapters on several 
of the XML-RPC toolkits.
</p>

<p>
<a href="http://www.amazon.com/exec/obidos/ASIN/0596001193/cookcomputing-20">Programming 
Web Services with XML-RPC</a> - Simon St. Laurent, Edd Dumbill, Joe Johnston 
(O'Reilly) 
</p>

<h3><a id="7.3"></a>7.3 Websites</h3>

<p>
<a href="http://www.xml-rpc.com/">XML-RPC.com</a> - specfications, implementations, 
  services, etc.
</p>

<p>
<a href="http://www.xml-rpc.net/">XML-RPC.NET Site</a> 
  - home of XML-RPC.NET
</p>

<p>
<a href="http://www.cookcomputing.com/">Cook Computing</a> 
  - Charles Cook's website and blog often has posts relating to XML-RPC.NET.
</p>

<h3><a id="7.4"></a>7.4 Mailing Lists</h3>

<p>
There are two relevant Yahoo groups:
</p>

<p>
<a href="http://groups.yahoo.com/group/xml-rpc/">xml-rpc</a> - &quot; This 
list provides a forum for discussing and implementing the XML-RPC specification 
as a cross-platform protocol.&quot;
</p>

<p>
<a href="http://groups.yahoo.com/group/XMLRPCNET/">XMLRPCNET</a> - &quot;Discussion 
  of the XML-RPC.NET library.&quot;
</p>

<h3><a id="7.5"></a>7.5 Articles and Tutorials</h3>

<p>
Eric Kidd's <a href="http://xmlrpc-c.sourceforge.net/xmlrpc-howto/xmlrpc-howto.html">XML-RPC 
HOWTO</a> provides useful information on implementing clients and servers in 
a variety of languages.
</p>

<h3><a id="7.6"></a>7.6 Sample Services</h3>

<p>
The <a href="http://www.xml-rpc.net/doc/xmlrpcdemos.html">XML-RPC.NET Demos</a> page contains links to some XML-RPC services implemented using
XML-RPC.NET.
</p>

</div>

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
    _uacct = "UA-444146-2";
    urchinTracker();
</script>

</body>
</html>
